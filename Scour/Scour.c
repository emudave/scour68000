
// Dave's Scour 68000 Emulator v0.005 - C Output

#include "Scour.h"

ScopFunc ScopTable[];

static struct Sco CheckInterrupt(struct Sco o, struct Scour *sc)
{
	int mask = 0;
	u32 tmp = 0;

	mask = (o.sr >> 8) & 7; // Get interrupt mask
	if (sc->irq < 7 && sc->irq <= mask) return o; // This interrupt level is not allowed

	// Get PC:
	tmp = (o.pc - sc->membase) << 1;
	// Push PC
	sc->d[0xf] -= 4;
	sc->write32(sc->d[0xf], tmp);

	// Push SR
	sc->d[0xf] -= 2;
	sc->write16(sc->d[0xf], (u16)o.sr);

	// Get IRQ vector address:
	tmp = sc->read32(0x60 + (sc->irq << 2));
	o.pc = sc->membase + (tmp >> 1);
	o.sr = 0x2000 | (sc->irq << 8); // Supervisor mode + IRQ number
	sc->irq = 0; // Clear IRQ todo - is this right?
	o.cycles -= 46; // Take some cycles
	o.pc = sc->checkpc(o.pc);
	return o;
}

void ScourRun(struct Scour *sc)
{
	struct Sco o = sc->o;
	if (sc->irq)
	{
		o = CheckInterrupt(o, sc);
		// Check for interrupt using up all the cycles:
		if (o.cycles < 0) { sc->o = o; return; }
	}
	do { o = ScopTable[*o.pc] (o, sc); } while (o.cycles > 0);
	sc->o = o;
}

// ---------------------------- Opcodes ---------------------------
// Called if an opcode is not recognised:
static struct Sco Op____(struct Sco o, struct Scour *sc) { (void)sc; o.cycles = -256; return o; }

// ---------- [0000] ori.b #$33, d0 ----------
static struct Sco Op0000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0010] ori.b #$33, (a0) ----------
static struct Sco Op0010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0018] ori.b #$33, (a0)+ ----------
static struct Sco Op0018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [001f] ori.b #$33, (a7)+ ----------
static struct Sco Op001f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0020] ori.b #$33, -(a0) ----------
static struct Sco Op0020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0027] ori.b #$33, -(a7) ----------
static struct Sco Op0027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0028] ori.b #$33, ($3333,a0) ----------
static struct Sco Op0028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0030] ori.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0038] ori.b #$33, $3333.w ----------
static struct Sco Op0038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0039] ori.b #$33, $33333333.l ----------
static struct Sco Op0039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [003a] ori.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op003a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [003b] ori.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op003b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [003c] ori.b #$33, ccr ----------
static struct Sco Op003c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into res:
	res = (s8)o.pc[1]; // Fetch immediate value

	val = o.sr & 0xff;
	val |= res;
	o.sr = (o.sr & ~0xff) | (val & 0xff);
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0040] ori.w #$3333, d0 ----------
static struct Sco Op0040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0050] ori.w #$3333, (a0) ----------
static struct Sco Op0050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0058] ori.w #$3333, (a0)+ ----------
static struct Sco Op0058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [005f] ori.w #$3333, (a7)+ ----------
static struct Sco Op005f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0060] ori.w #$3333, -(a0) ----------
static struct Sco Op0060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0067] ori.w #$3333, -(a7) ----------
static struct Sco Op0067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0068] ori.w #$3333, ($3333,a0) ----------
static struct Sco Op0068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0070] ori.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op0070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0078] ori.w #$3333, $3333.w ----------
static struct Sco Op0078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0079] ori.w #$3333, $33333333.l ----------
static struct Sco Op0079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [007a] ori.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op007a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [007b] ori.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op007b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [007c] ori.w #$3333, sr ----------
static struct Sco Op007c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into res:
	res = (s16)o.pc[1]; // Fetch immediate value

	val = o.sr;
	val |= res;
	o.sr = val;
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0080] ori.l #$33333333, d0 ----------
static struct Sco Op0080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0090] ori.l #$33333333, (a0) ----------
static struct Sco Op0090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0098] ori.l #$33333333, (a0)+ ----------
static struct Sco Op0098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [009f] ori.l #$33333333, (a7)+ ----------
static struct Sco Op009f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00a0] ori.l #$33333333, -(a0) ----------
static struct Sco Op00a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00a7] ori.l #$33333333, -(a7) ----------
static struct Sco Op00a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00a8] ori.l #$33333333, ($3333,a0) ----------
static struct Sco Op00a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00b0] ori.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op00b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00b8] ori.l #$33333333, $3333.w ----------
static struct Sco Op00b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00b9] ori.l #$33333333, $33333333.l ----------
static struct Sco Op00b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00ba] ori.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op00ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [00bb] ori.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op00bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0100] btst d0, d0 ----------
static struct Sco Op0100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0110] btst d0, (a0) ----------
static struct Sco Op0110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0118] btst d0, (a0)+ ----------
static struct Sco Op0118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [011f] btst d0, (a7)+ ----------
static struct Sco Op011f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0120] btst d0, -(a0) ----------
static struct Sco Op0120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0127] btst d0, -(a7) ----------
static struct Sco Op0127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0128] btst d0, ($3333,a0) ----------
static struct Sco Op0128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0130] btst d0, ($33,a0,d3.w*2) ----------
static struct Sco Op0130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0138] btst d0, $3333.w ----------
static struct Sco Op0138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0139] btst d0, $33333333.l ----------
static struct Sco Op0139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [013a] btst d0, ($3333,pc); =3335 ----------
static struct Sco Op013a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [013b] btst d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op013b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [013c] btst d0, #$33 ----------
static struct Sco Op013c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0140] bchg d0, d0 ----------
static struct Sco Op0140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0150] bchg d0, (a0) ----------
static struct Sco Op0150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0158] bchg d0, (a0)+ ----------
static struct Sco Op0158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [015f] bchg d0, (a7)+ ----------
static struct Sco Op015f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0160] bchg d0, -(a0) ----------
static struct Sco Op0160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0167] bchg d0, -(a7) ----------
static struct Sco Op0167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0168] bchg d0, ($3333,a0) ----------
static struct Sco Op0168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0170] bchg d0, ($33,a0,d3.w*2) ----------
static struct Sco Op0170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0178] bchg d0, $3333.w ----------
static struct Sco Op0178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0179] bchg d0, $33333333.l ----------
static struct Sco Op0179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [017a] bchg d0, ($3333,pc); =3335 ----------
static struct Sco Op017a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [017b] bchg d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op017b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0180] bclr d0, d0 ----------
static struct Sco Op0180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0190] bclr d0, (a0) ----------
static struct Sco Op0190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0198] bclr d0, (a0)+ ----------
static struct Sco Op0198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [019f] bclr d0, (a7)+ ----------
static struct Sco Op019f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01a0] bclr d0, -(a0) ----------
static struct Sco Op01a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01a7] bclr d0, -(a7) ----------
static struct Sco Op01a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01a8] bclr d0, ($3333,a0) ----------
static struct Sco Op01a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01b0] bclr d0, ($33,a0,d3.w*2) ----------
static struct Sco Op01b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01b8] bclr d0, $3333.w ----------
static struct Sco Op01b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01b9] bclr d0, $33333333.l ----------
static struct Sco Op01b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01ba] bclr d0, ($3333,pc); =3335 ----------
static struct Sco Op01ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01bb] bclr d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op01bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01c0] bset d0, d0 ----------
static struct Sco Op01c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01d0] bset d0, (a0) ----------
static struct Sco Op01d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01d8] bset d0, (a0)+ ----------
static struct Sco Op01d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01df] bset d0, (a7)+ ----------
static struct Sco Op01df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01e0] bset d0, -(a0) ----------
static struct Sco Op01e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01e7] bset d0, -(a7) ----------
static struct Sco Op01e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01e8] bset d0, ($3333,a0) ----------
static struct Sco Op01e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01f0] bset d0, ($33,a0,d3.w*2) ----------
static struct Sco Op01f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01f8] bset d0, $3333.w ----------
static struct Sco Op01f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01f9] bset d0, $33333333.l ----------
static struct Sco Op01f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01fa] bset d0, ($3333,pc); =3335 ----------
static struct Sco Op01fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [01fb] bset d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op01fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0200] andi.b #$33, d0 ----------
static struct Sco Op0200(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0210] andi.b #$33, (a0) ----------
static struct Sco Op0210(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0218] andi.b #$33, (a0)+ ----------
static struct Sco Op0218(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [021f] andi.b #$33, (a7)+ ----------
static struct Sco Op021f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0220] andi.b #$33, -(a0) ----------
static struct Sco Op0220(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0227] andi.b #$33, -(a7) ----------
static struct Sco Op0227(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0228] andi.b #$33, ($3333,a0) ----------
static struct Sco Op0228(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0230] andi.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0230(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0238] andi.b #$33, $3333.w ----------
static struct Sco Op0238(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0239] andi.b #$33, $33333333.l ----------
static struct Sco Op0239(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [023a] andi.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op023a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [023b] andi.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op023b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [023c] andi.b #$33, ccr ----------
static struct Sco Op023c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into res:
	res = (s8)o.pc[1]; // Fetch immediate value

	val = o.sr & 0xff;
	val &= res;
	o.sr = (o.sr & ~0xff) | (val & 0xff);
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0240] andi.w #$3333, d0 ----------
static struct Sco Op0240(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0250] andi.w #$3333, (a0) ----------
static struct Sco Op0250(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0258] andi.w #$3333, (a0)+ ----------
static struct Sco Op0258(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [025f] andi.w #$3333, (a7)+ ----------
static struct Sco Op025f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0260] andi.w #$3333, -(a0) ----------
static struct Sco Op0260(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0267] andi.w #$3333, -(a7) ----------
static struct Sco Op0267(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0268] andi.w #$3333, ($3333,a0) ----------
static struct Sco Op0268(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0270] andi.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op0270(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0278] andi.w #$3333, $3333.w ----------
static struct Sco Op0278(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0279] andi.w #$3333, $33333333.l ----------
static struct Sco Op0279(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [027a] andi.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op027a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [027b] andi.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op027b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [027c] andi.w #$3333, sr ----------
static struct Sco Op027c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into res:
	res = (s16)o.pc[1]; // Fetch immediate value

	val = o.sr;
	val &= res;
	o.sr = val;
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0280] andi.l #$33333333, d0 ----------
static struct Sco Op0280(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0290] andi.l #$33333333, (a0) ----------
static struct Sco Op0290(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0298] andi.l #$33333333, (a0)+ ----------
static struct Sco Op0298(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [029f] andi.l #$33333333, (a7)+ ----------
static struct Sco Op029f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02a0] andi.l #$33333333, -(a0) ----------
static struct Sco Op02a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02a7] andi.l #$33333333, -(a7) ----------
static struct Sco Op02a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02a8] andi.l #$33333333, ($3333,a0) ----------
static struct Sco Op02a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02b0] andi.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op02b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02b8] andi.l #$33333333, $3333.w ----------
static struct Sco Op02b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02b9] andi.l #$33333333, $33333333.l ----------
static struct Sco Op02b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02ba] andi.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op02ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [02bb] andi.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op02bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0400] subi.b #$33, d0 ----------
static struct Sco Op0400(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0410] subi.b #$33, (a0) ----------
static struct Sco Op0410(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0418] subi.b #$33, (a0)+ ----------
static struct Sco Op0418(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [041f] subi.b #$33, (a7)+ ----------
static struct Sco Op041f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0420] subi.b #$33, -(a0) ----------
static struct Sco Op0420(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0427] subi.b #$33, -(a7) ----------
static struct Sco Op0427(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0428] subi.b #$33, ($3333,a0) ----------
static struct Sco Op0428(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0430] subi.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0430(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0438] subi.b #$33, $3333.w ----------
static struct Sco Op0438(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0439] subi.b #$33, $33333333.l ----------
static struct Sco Op0439(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [043a] subi.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op043a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [043b] subi.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op043b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0440] subi.w #$3333, d0 ----------
static struct Sco Op0440(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0450] subi.w #$3333, (a0) ----------
static struct Sco Op0450(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0458] subi.w #$3333, (a0)+ ----------
static struct Sco Op0458(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [045f] subi.w #$3333, (a7)+ ----------
static struct Sco Op045f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0460] subi.w #$3333, -(a0) ----------
static struct Sco Op0460(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0467] subi.w #$3333, -(a7) ----------
static struct Sco Op0467(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0468] subi.w #$3333, ($3333,a0) ----------
static struct Sco Op0468(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0470] subi.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op0470(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0478] subi.w #$3333, $3333.w ----------
static struct Sco Op0478(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0479] subi.w #$3333, $33333333.l ----------
static struct Sco Op0479(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [047a] subi.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op047a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [047b] subi.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op047b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0480] subi.l #$33333333, d0 ----------
static struct Sco Op0480(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0490] subi.l #$33333333, (a0) ----------
static struct Sco Op0490(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0498] subi.l #$33333333, (a0)+ ----------
static struct Sco Op0498(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [049f] subi.l #$33333333, (a7)+ ----------
static struct Sco Op049f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04a0] subi.l #$33333333, -(a0) ----------
static struct Sco Op04a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04a7] subi.l #$33333333, -(a7) ----------
static struct Sco Op04a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04a8] subi.l #$33333333, ($3333,a0) ----------
static struct Sco Op04a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04b0] subi.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op04b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04b8] subi.l #$33333333, $3333.w ----------
static struct Sco Op04b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04b9] subi.l #$33333333, $33333333.l ----------
static struct Sco Op04b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04ba] subi.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op04ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [04bb] subi.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op04bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0600] addi.b #$33, d0 ----------
static struct Sco Op0600(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0610] addi.b #$33, (a0) ----------
static struct Sco Op0610(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0618] addi.b #$33, (a0)+ ----------
static struct Sco Op0618(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [061f] addi.b #$33, (a7)+ ----------
static struct Sco Op061f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0620] addi.b #$33, -(a0) ----------
static struct Sco Op0620(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0627] addi.b #$33, -(a7) ----------
static struct Sco Op0627(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0628] addi.b #$33, ($3333,a0) ----------
static struct Sco Op0628(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0630] addi.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0630(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0638] addi.b #$33, $3333.w ----------
static struct Sco Op0638(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0639] addi.b #$33, $33333333.l ----------
static struct Sco Op0639(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [063a] addi.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op063a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [063b] addi.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op063b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0640] addi.w #$3333, d0 ----------
static struct Sco Op0640(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0650] addi.w #$3333, (a0) ----------
static struct Sco Op0650(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0658] addi.w #$3333, (a0)+ ----------
static struct Sco Op0658(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [065f] addi.w #$3333, (a7)+ ----------
static struct Sco Op065f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0660] addi.w #$3333, -(a0) ----------
static struct Sco Op0660(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0667] addi.w #$3333, -(a7) ----------
static struct Sco Op0667(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0668] addi.w #$3333, ($3333,a0) ----------
static struct Sco Op0668(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0670] addi.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op0670(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0678] addi.w #$3333, $3333.w ----------
static struct Sco Op0678(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0679] addi.w #$3333, $33333333.l ----------
static struct Sco Op0679(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [067a] addi.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op067a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [067b] addi.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op067b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0680] addi.l #$33333333, d0 ----------
static struct Sco Op0680(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0690] addi.l #$33333333, (a0) ----------
static struct Sco Op0690(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0698] addi.l #$33333333, (a0)+ ----------
static struct Sco Op0698(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [069f] addi.l #$33333333, (a7)+ ----------
static struct Sco Op069f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06a0] addi.l #$33333333, -(a0) ----------
static struct Sco Op06a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06a7] addi.l #$33333333, -(a7) ----------
static struct Sco Op06a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06a8] addi.l #$33333333, ($3333,a0) ----------
static struct Sco Op06a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06b0] addi.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op06b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06b8] addi.l #$33333333, $3333.w ----------
static struct Sco Op06b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06b9] addi.l #$33333333, $33333333.l ----------
static struct Sco Op06b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06ba] addi.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op06ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [06bb] addi.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op06bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0800] btst #$33, d0 ----------
static struct Sco Op0800(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0810] btst #$33, (a0) ----------
static struct Sco Op0810(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0818] btst #$33, (a0)+ ----------
static struct Sco Op0818(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [081f] btst #$33, (a7)+ ----------
static struct Sco Op081f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0820] btst #$33, -(a0) ----------
static struct Sco Op0820(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0827] btst #$33, -(a7) ----------
static struct Sco Op0827(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0828] btst #$33, ($3333,a0) ----------
static struct Sco Op0828(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0830] btst #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0830(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0838] btst #$33, $3333.w ----------
static struct Sco Op0838(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0839] btst #$33, $33333333.l ----------
static struct Sco Op0839(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [083a] btst #$33, ($3333,pc); =3337 ----------
static struct Sco Op083a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [083b] btst #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op083b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [083c] btst #$33, #$33 ----------
static struct Sco Op083c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[2]; // Fetch immediate value

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0840] bchg #$33, d0 ----------
static struct Sco Op0840(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0850] bchg #$33, (a0) ----------
static struct Sco Op0850(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0858] bchg #$33, (a0)+ ----------
static struct Sco Op0858(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [085f] bchg #$33, (a7)+ ----------
static struct Sco Op085f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0860] bchg #$33, -(a0) ----------
static struct Sco Op0860(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0867] bchg #$33, -(a7) ----------
static struct Sco Op0867(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0868] bchg #$33, ($3333,a0) ----------
static struct Sco Op0868(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0870] bchg #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0870(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0878] bchg #$33, $3333.w ----------
static struct Sco Op0878(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0879] bchg #$33, $33333333.l ----------
static struct Sco Op0879(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [087a] bchg #$33, ($3333,pc); =3337 ----------
static struct Sco Op087a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [087b] bchg #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op087b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val ^= bit; // Toggle bit

	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0880] bclr #$33, d0 ----------
static struct Sco Op0880(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0890] bclr #$33, (a0) ----------
static struct Sco Op0890(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0898] bclr #$33, (a0)+ ----------
static struct Sco Op0898(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [089f] bclr #$33, (a7)+ ----------
static struct Sco Op089f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08a0] bclr #$33, -(a0) ----------
static struct Sco Op08a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08a7] bclr #$33, -(a7) ----------
static struct Sco Op08a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08a8] bclr #$33, ($3333,a0) ----------
static struct Sco Op08a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08b0] bclr #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op08b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08b8] bclr #$33, $3333.w ----------
static struct Sco Op08b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08b9] bclr #$33, $33333333.l ----------
static struct Sco Op08b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08ba] bclr #$33, ($3333,pc); =3337 ----------
static struct Sco Op08ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08bb] bclr #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op08bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val &= ~bit; // Clear bit

	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08c0] bset #$33, d0 ----------
static struct Sco Op08c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 31); // Make bit mask

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08d0] bset #$33, (a0) ----------
static struct Sco Op08d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08d8] bset #$33, (a0)+ ----------
static struct Sco Op08d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08df] bset #$33, (a7)+ ----------
static struct Sco Op08df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08e0] bset #$33, -(a0) ----------
static struct Sco Op08e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08e7] bset #$33, -(a7) ----------
static struct Sco Op08e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08e8] bset #$33, ($3333,a0) ----------
static struct Sco Op08e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08f0] bset #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op08f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08f8] bset #$33, $3333.w ----------
static struct Sco Op08f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08f9] bset #$33, $33333333.l ----------
static struct Sco Op08f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08fa] bset #$33, ($3333,pc); =3337 ----------
static struct Sco Op08fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [08fb] bset #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op08fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 bit = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	bit = 1 << (val & 7); // Make bit mask

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	o.sr &= ~4;
	if ((val & bit) == 0) o.sr |= 4;  // Do btst and get Z flag

	val |= bit; // Set bit

	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a00] eori.b #$33, d0 ----------
static struct Sco Op0a00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a10] eori.b #$33, (a0) ----------
static struct Sco Op0a10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a18] eori.b #$33, (a0)+ ----------
static struct Sco Op0a18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a1f] eori.b #$33, (a7)+ ----------
static struct Sco Op0a1f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a20] eori.b #$33, -(a0) ----------
static struct Sco Op0a20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a27] eori.b #$33, -(a7) ----------
static struct Sco Op0a27(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a28] eori.b #$33, ($3333,a0) ----------
static struct Sco Op0a28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a30] eori.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0a30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a38] eori.b #$33, $3333.w ----------
static struct Sco Op0a38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a39] eori.b #$33, $33333333.l ----------
static struct Sco Op0a39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a3a] eori.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op0a3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a3b] eori.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op0a3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a3c] eori.b #$33, ccr ----------
static struct Sco Op0a3c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into res:
	res = (s8)o.pc[1]; // Fetch immediate value

	val = o.sr & 0xff;
	val ^= res;
	o.sr = (o.sr & ~0xff) | (val & 0xff);
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a40] eori.w #$3333, d0 ----------
static struct Sco Op0a40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a50] eori.w #$3333, (a0) ----------
static struct Sco Op0a50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a58] eori.w #$3333, (a0)+ ----------
static struct Sco Op0a58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a5f] eori.w #$3333, (a7)+ ----------
static struct Sco Op0a5f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a60] eori.w #$3333, -(a0) ----------
static struct Sco Op0a60(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a67] eori.w #$3333, -(a7) ----------
static struct Sco Op0a67(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a68] eori.w #$3333, ($3333,a0) ----------
static struct Sco Op0a68(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a70] eori.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op0a70(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a78] eori.w #$3333, $3333.w ----------
static struct Sco Op0a78(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a79] eori.w #$3333, $33333333.l ----------
static struct Sco Op0a79(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 4;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a7a] eori.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op0a7a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a7b] eori.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op0a7b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a7c] eori.w #$3333, sr ----------
static struct Sco Op0a7c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into res:
	res = (s16)o.pc[1]; // Fetch immediate value

	val = o.sr;
	val ^= res;
	o.sr = val;
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a80] eori.l #$33333333, d0 ----------
static struct Sco Op0a80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a90] eori.l #$33333333, (a0) ----------
static struct Sco Op0a90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a98] eori.l #$33333333, (a0)+ ----------
static struct Sco Op0a98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0a9f] eori.l #$33333333, (a7)+ ----------
static struct Sco Op0a9f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0aa0] eori.l #$33333333, -(a0) ----------
static struct Sco Op0aa0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0aa7] eori.l #$33333333, -(a7) ----------
static struct Sco Op0aa7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0aa8] eori.l #$33333333, ($3333,a0) ----------
static struct Sco Op0aa8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0ab0] eori.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op0ab0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0ab8] eori.l #$33333333, $3333.w ----------
static struct Sco Op0ab8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0ab9] eori.l #$33333333, $33333333.l ----------
static struct Sco Op0ab9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0aba] eori.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op0aba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0abb] eori.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op0abb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c00] cmpi.b #$33, d0 ----------
static struct Sco Op0c00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c10] cmpi.b #$33, (a0) ----------
static struct Sco Op0c10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c18] cmpi.b #$33, (a0)+ ----------
static struct Sco Op0c18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c1f] cmpi.b #$33, (a7)+ ----------
static struct Sco Op0c1f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c20] cmpi.b #$33, -(a0) ----------
static struct Sco Op0c20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c27] cmpi.b #$33, -(a7) ----------
static struct Sco Op0c27(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c28] cmpi.b #$33, ($3333,a0) ----------
static struct Sco Op0c28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c30] cmpi.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op0c30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c38] cmpi.b #$33, $3333.w ----------
static struct Sco Op0c38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c39] cmpi.b #$33, $33333333.l ----------
static struct Sco Op0c39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c3a] cmpi.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op0c3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c3b] cmpi.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op0c3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c3c]  ----------
static struct Sco Op0c3c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// EaRead : Read '#$33' into a:
	a = (s8)o.pc[2]; // Fetch immediate value

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c40] cmpi.w #$3333, d0 ----------
static struct Sco Op0c40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c50] cmpi.w #$3333, (a0) ----------
static struct Sco Op0c50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c58] cmpi.w #$3333, (a0)+ ----------
static struct Sco Op0c58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c5f] cmpi.w #$3333, (a7)+ ----------
static struct Sco Op0c5f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c60] cmpi.w #$3333, -(a0) ----------
static struct Sco Op0c60(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c67] cmpi.w #$3333, -(a7) ----------
static struct Sco Op0c67(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c68] cmpi.w #$3333, ($3333,a0) ----------
static struct Sco Op0c68(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c70] cmpi.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op0c70(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c78] cmpi.w #$3333, $3333.w ----------
static struct Sco Op0c78(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c79] cmpi.w #$3333, $33333333.l ----------
static struct Sco Op0c79(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c7a] cmpi.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op0c7a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c7b] cmpi.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op0c7b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c7c]  ----------
static struct Sco Op0c7c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaRead : Read '#$3333' into a:
	a = (s16)o.pc[2]; // Fetch immediate value

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c80] cmpi.l #$33333333, d0 ----------
static struct Sco Op0c80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c90] cmpi.l #$33333333, (a0) ----------
static struct Sco Op0c90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c98] cmpi.l #$33333333, (a0)+ ----------
static struct Sco Op0c98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0c9f] cmpi.l #$33333333, (a7)+ ----------
static struct Sco Op0c9f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0ca0] cmpi.l #$33333333, -(a0) ----------
static struct Sco Op0ca0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0ca7] cmpi.l #$33333333, -(a7) ----------
static struct Sco Op0ca7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0ca8] cmpi.l #$33333333, ($3333,a0) ----------
static struct Sco Op0ca8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0cb0] cmpi.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op0cb0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0cb8] cmpi.l #$33333333, $3333.w ----------
static struct Sco Op0cb8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0cb9] cmpi.l #$33333333, $33333333.l ----------
static struct Sco Op0cb9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 5;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0cba] cmpi.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op0cba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0cbb] cmpi.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op0cbb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 4;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [0cbc]  ----------
static struct Sco Op0cbc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaRead : Read '#$33333333' into a:
	a = (o.pc[3] << 16) | o.pc[4]; // Fetch 32-bit value

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C
	o.pc += 5;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1000] move.b d0, d0 ----------
static struct Sco Op1000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1010] move.b (a0), d0 ----------
static struct Sco Op1010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1018] move.b (a0)+, d0 ----------
static struct Sco Op1018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [101f] move.b (a7)+, d0 ----------
static struct Sco Op101f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1020] move.b -(a0), d0 ----------
static struct Sco Op1020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1027] move.b -(a7), d0 ----------
static struct Sco Op1027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1028] move.b ($3333,a0), d0 ----------
static struct Sco Op1028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1030] move.b ($33,a0,d3.w*2), d0 ----------
static struct Sco Op1030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1038] move.b $3333.w, d0 ----------
static struct Sco Op1038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1039] move.b $33333333.l, d0 ----------
static struct Sco Op1039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [103a] move.b ($3333,pc), d0; =3335 ----------
static struct Sco Op103a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [103b] move.b ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op103b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [103c] move.b #$33, d0 ----------
static struct Sco Op103c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= val & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1080] move.b d0, (a0) ----------
static struct Sco Op1080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1090] move.b (a0), (a0) ----------
static struct Sco Op1090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1098] move.b (a0)+, (a0) ----------
static struct Sco Op1098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [109f] move.b (a7)+, (a0) ----------
static struct Sco Op109f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10a0] move.b -(a0), (a0) ----------
static struct Sco Op10a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10a7] move.b -(a7), (a0) ----------
static struct Sco Op10a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10a8] move.b ($3333,a0), (a0) ----------
static struct Sco Op10a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10b0] move.b ($33,a0,d3.w*2), (a0) ----------
static struct Sco Op10b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10b8] move.b $3333.w, (a0) ----------
static struct Sco Op10b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10b9] move.b $33333333.l, (a0) ----------
static struct Sco Op10b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10ba] move.b ($3333,pc), (a0); =3335 ----------
static struct Sco Op10ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10bb] move.b ($33,pc,d3.w*2), (a0); =35 ----------
static struct Sco Op10bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10bc] move.b #$33, (a0) ----------
static struct Sco Op10bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10c0] move.b d0, (a0)+ ----------
static struct Sco Op10c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10d0] move.b (a0), (a0)+ ----------
static struct Sco Op10d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10d8] move.b (a0)+, (a0)+ ----------
static struct Sco Op10d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10df] move.b (a7)+, (a0)+ ----------
static struct Sco Op10df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10e0] move.b -(a0), (a0)+ ----------
static struct Sco Op10e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10e7] move.b -(a7), (a0)+ ----------
static struct Sco Op10e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10e8] move.b ($3333,a0), (a0)+ ----------
static struct Sco Op10e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10f0] move.b ($33,a0,d3.w*2), (a0)+ ----------
static struct Sco Op10f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10f8] move.b $3333.w, (a0)+ ----------
static struct Sco Op10f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10f9] move.b $33333333.l, (a0)+ ----------
static struct Sco Op10f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10fa] move.b ($3333,pc), (a0)+; =3335 ----------
static struct Sco Op10fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10fb] move.b ($33,pc,d3.w*2), (a0)+; =35 ----------
static struct Sco Op10fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [10fc] move.b #$33, (a0)+ ----------
static struct Sco Op10fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1100] move.b d0, -(a0) ----------
static struct Sco Op1100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1110] move.b (a0), -(a0) ----------
static struct Sco Op1110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1118] move.b (a0)+, -(a0) ----------
static struct Sco Op1118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [111f] move.b (a7)+, -(a0) ----------
static struct Sco Op111f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1120] move.b -(a0), -(a0) ----------
static struct Sco Op1120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1127] move.b -(a7), -(a0) ----------
static struct Sco Op1127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1128] move.b ($3333,a0), -(a0) ----------
static struct Sco Op1128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1130] move.b ($33,a0,d3.w*2), -(a0) ----------
static struct Sco Op1130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1138] move.b $3333.w, -(a0) ----------
static struct Sco Op1138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1139] move.b $33333333.l, -(a0) ----------
static struct Sco Op1139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [113a] move.b ($3333,pc), -(a0); =3335 ----------
static struct Sco Op113a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [113b] move.b ($33,pc,d3.w*2), -(a0); =35 ----------
static struct Sco Op113b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [113c] move.b #$33, -(a0) ----------
static struct Sco Op113c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1140] move.b d0, ($3333,a0) ----------
static struct Sco Op1140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1150] move.b (a0), ($3333,a0) ----------
static struct Sco Op1150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1158] move.b (a0)+, ($3333,a0) ----------
static struct Sco Op1158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [115f] move.b (a7)+, ($3333,a0) ----------
static struct Sco Op115f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1160] move.b -(a0), ($3333,a0) ----------
static struct Sco Op1160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1167] move.b -(a7), ($3333,a0) ----------
static struct Sco Op1167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1168] move.b ($3333,a0), ($3333,a0) ----------
static struct Sco Op1168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1170] move.b ($33,a0,d3.w*2), ($3333,a0) ----------
static struct Sco Op1170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1178] move.b $3333.w, ($3333,a0) ----------
static struct Sco Op1178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1179] move.b $33333333.l, ($3333,a0) ----------
static struct Sco Op1179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [117a] move.b ($3333,pc), ($3333,a0); =3335 ----------
static struct Sco Op117a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [117b] move.b ($33,pc,d3.w*2), ($3333,a0); =35 ----------
static struct Sco Op117b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [117c] move.b #$33, ($3333,a0) ----------
static struct Sco Op117c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1180] move.b d0, ($33,a0,d3.w*2) ----------
static struct Sco Op1180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1190] move.b (a0), ($33,a0,d3.w*2) ----------
static struct Sco Op1190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1198] move.b (a0)+, ($33,a0,d3.w*2) ----------
static struct Sco Op1198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [119f] move.b (a7)+, ($33,a0,d3.w*2) ----------
static struct Sco Op119f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11a0] move.b -(a0), ($33,a0,d3.w*2) ----------
static struct Sco Op11a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11a7] move.b -(a7), ($33,a0,d3.w*2) ----------
static struct Sco Op11a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11a8] move.b ($3333,a0), ($33,a0,d3.w*2) ----------
static struct Sco Op11a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11b0] move.b ($33,a0,d3.w*2), ($33,a0,d3.w*2) ----------
static struct Sco Op11b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11b8] move.b $3333.w, ($33,a0,d3.w*2) ----------
static struct Sco Op11b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11b9] move.b $33333333.l, ($33,a0,d3.w*2) ----------
static struct Sco Op11b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11ba] move.b ($3333,pc), ($33,a0,d3.w*2); =3335 ----------
static struct Sco Op11ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11bb] move.b ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 ----------
static struct Sco Op11bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11bc] move.b #$33, ($33,a0,d3.w*2) ----------
static struct Sco Op11bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11c0] move.b d0, $3333.w ----------
static struct Sco Op11c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11d0] move.b (a0), $3333.w ----------
static struct Sco Op11d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11d8] move.b (a0)+, $3333.w ----------
static struct Sco Op11d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11df] move.b (a7)+, $3333.w ----------
static struct Sco Op11df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11e0] move.b -(a0), $3333.w ----------
static struct Sco Op11e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11e7] move.b -(a7), $3333.w ----------
static struct Sco Op11e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11e8] move.b ($3333,a0), $3333.w ----------
static struct Sco Op11e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11f0] move.b ($33,a0,d3.w*2), $3333.w ----------
static struct Sco Op11f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11f8] move.b $3333.w, $3333.w ----------
static struct Sco Op11f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11f9] move.b $33333333.l, $3333.w ----------
static struct Sco Op11f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11fa] move.b ($3333,pc), $3333.w; =3335 ----------
static struct Sco Op11fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11fb] move.b ($33,pc,d3.w*2), $3333.w; =35 ----------
static struct Sco Op11fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [11fc] move.b #$33, $3333.w ----------
static struct Sco Op11fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13c0] move.b d0, $33333333.l ----------
static struct Sco Op13c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13d0] move.b (a0), $33333333.l ----------
static struct Sco Op13d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13d8] move.b (a0)+, $33333333.l ----------
static struct Sco Op13d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13df] move.b (a7)+, $33333333.l ----------
static struct Sco Op13df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13e0] move.b -(a0), $33333333.l ----------
static struct Sco Op13e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13e7] move.b -(a7), $33333333.l ----------
static struct Sco Op13e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13e8] move.b ($3333,a0), $33333333.l ----------
static struct Sco Op13e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13f0] move.b ($33,a0,d3.w*2), $33333333.l ----------
static struct Sco Op13f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13f8] move.b $3333.w, $33333333.l ----------
static struct Sco Op13f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13f9] move.b $33333333.l, $33333333.l ----------
static struct Sco Op13f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13fa] move.b ($3333,pc), $33333333.l; =3335 ----------
static struct Sco Op13fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13fb] move.b ($33,pc,d3.w*2), $33333333.l; =35 ----------
static struct Sco Op13fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [13fc] move.b #$33, $33333333.l ----------
static struct Sco Op13fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15c0] move.b d0, ($3333,pc); =3335 ----------
static struct Sco Op15c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15d0] move.b (a0), ($3333,pc); =3335 ----------
static struct Sco Op15d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15d8] move.b (a0)+, ($3333,pc); =3335 ----------
static struct Sco Op15d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15df] move.b (a7)+, ($3333,pc); =3335 ----------
static struct Sco Op15df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15e0] move.b -(a0), ($3333,pc); =3335 ----------
static struct Sco Op15e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15e7] move.b -(a7), ($3333,pc); =3335 ----------
static struct Sco Op15e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15e8] move.b ($3333,a0), ($3333,pc); =3337 ----------
static struct Sco Op15e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15f0] move.b ($33,a0,d3.w*2), ($3333,pc); =3337 ----------
static struct Sco Op15f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15f8] move.b $3333.w, ($3333,pc); =3337 ----------
static struct Sco Op15f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15f9] move.b $33333333.l, ($3333,pc); =3339 ----------
static struct Sco Op15f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15fa] move.b ($3333,pc), ($3333,pc); =3337 ----------
static struct Sco Op15fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15fb] move.b ($33,pc,d3.w*2), ($3333,pc); =3337 ----------
static struct Sco Op15fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [15fc] move.b #$33, ($3333,pc); =3337 ----------
static struct Sco Op15fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17c0] move.b d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op17c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17d0] move.b (a0), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op17d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17d8] move.b (a0)+, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op17d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17df] move.b (a7)+, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op17df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17e0] move.b -(a0), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op17e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17e7] move.b -(a7), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op17e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17e8] move.b ($3333,a0), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op17e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17f0] move.b ($33,a0,d3.w*2), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op17f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17f8] move.b $3333.w, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op17f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17f9] move.b $33333333.l, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op17f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17fa] move.b ($3333,pc), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op17fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17fb] move.b ($33,pc,d3.w*2), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op17fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [17fc] move.b #$33, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op17fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ec0] move.b d0, (a7)+ ----------
static struct Sco Op1ec0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ed0] move.b (a0), (a7)+ ----------
static struct Sco Op1ed0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ed8] move.b (a0)+, (a7)+ ----------
static struct Sco Op1ed8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1edf] move.b (a7)+, (a7)+ ----------
static struct Sco Op1edf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ee0] move.b -(a0), (a7)+ ----------
static struct Sco Op1ee0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ee7] move.b -(a7), (a7)+ ----------
static struct Sco Op1ee7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ee8] move.b ($3333,a0), (a7)+ ----------
static struct Sco Op1ee8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ef0] move.b ($33,a0,d3.w*2), (a7)+ ----------
static struct Sco Op1ef0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ef8] move.b $3333.w, (a7)+ ----------
static struct Sco Op1ef8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1ef9] move.b $33333333.l, (a7)+ ----------
static struct Sco Op1ef9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1efa] move.b ($3333,pc), (a7)+; =3335 ----------
static struct Sco Op1efa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1efb] move.b ($33,pc,d3.w*2), (a7)+; =35 ----------
static struct Sco Op1efb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1efc] move.b #$33, (a7)+ ----------
static struct Sco Op1efc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f00] move.b d0, -(a7) ----------
static struct Sco Op1f00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f10] move.b (a0), -(a7) ----------
static struct Sco Op1f10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f18] move.b (a0)+, -(a7) ----------
static struct Sco Op1f18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f1f] move.b (a7)+, -(a7) ----------
static struct Sco Op1f1f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f20] move.b -(a0), -(a7) ----------
static struct Sco Op1f20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f27] move.b -(a7), -(a7) ----------
static struct Sco Op1f27(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f28] move.b ($3333,a0), -(a7) ----------
static struct Sco Op1f28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f30] move.b ($33,a0,d3.w*2), -(a7) ----------
static struct Sco Op1f30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f38] move.b $3333.w, -(a7) ----------
static struct Sco Op1f38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f39] move.b $33333333.l, -(a7) ----------
static struct Sco Op1f39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f3a] move.b ($3333,pc), -(a7); =3335 ----------
static struct Sco Op1f3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f3b] move.b ($33,pc,d3.w*2), -(a7); =35 ----------
static struct Sco Op1f3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [1f3c] move.b #$33, -(a7) ----------
static struct Sco Op1f3c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write8(off, (u8)val);

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2000] move.l d0, d0 ----------
static struct Sco Op2000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2010] move.l (a0), d0 ----------
static struct Sco Op2010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2018] move.l (a0)+, d0 ----------
static struct Sco Op2018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [201f] move.l (a7)+, d0 ----------
static struct Sco Op201f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2020] move.l -(a0), d0 ----------
static struct Sco Op2020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2027] move.l -(a7), d0 ----------
static struct Sco Op2027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2028] move.l ($3333,a0), d0 ----------
static struct Sco Op2028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2030] move.l ($33,a0,d3.w*2), d0 ----------
static struct Sco Op2030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2038] move.l $3333.w, d0 ----------
static struct Sco Op2038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2039] move.l $33333333.l, d0 ----------
static struct Sco Op2039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [203a] move.l ($3333,pc), d0; =3335 ----------
static struct Sco Op203a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [203b] move.l ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op203b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [203c] move.l #$33333333, d0 ----------
static struct Sco Op203c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2040] movea.l d0, a0 ----------
static struct Sco Op2040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2050] movea.l (a0), a0 ----------
static struct Sco Op2050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2058] movea.l (a0)+, a0 ----------
static struct Sco Op2058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [205f] movea.l (a7)+, a0 ----------
static struct Sco Op205f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2060] movea.l -(a0), a0 ----------
static struct Sco Op2060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2067] movea.l -(a7), a0 ----------
static struct Sco Op2067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2068] movea.l ($3333,a0), a0 ----------
static struct Sco Op2068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2070] movea.l ($33,a0,d3.w*2), a0 ----------
static struct Sco Op2070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2078] movea.l $3333.w, a0 ----------
static struct Sco Op2078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2079] movea.l $33333333.l, a0 ----------
static struct Sco Op2079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [207a] movea.l ($3333,pc), a0; =3335 ----------
static struct Sco Op207a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [207b] movea.l ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Op207b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [207c] movea.l #$33333333, a0 ----------
static struct Sco Op207c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2080] move.l d0, (a0) ----------
static struct Sco Op2080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2090] move.l (a0), (a0) ----------
static struct Sco Op2090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2098] move.l (a0)+, (a0) ----------
static struct Sco Op2098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [209f] move.l (a7)+, (a0) ----------
static struct Sco Op209f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20a0] move.l -(a0), (a0) ----------
static struct Sco Op20a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20a7] move.l -(a7), (a0) ----------
static struct Sco Op20a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20a8] move.l ($3333,a0), (a0) ----------
static struct Sco Op20a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20b0] move.l ($33,a0,d3.w*2), (a0) ----------
static struct Sco Op20b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20b8] move.l $3333.w, (a0) ----------
static struct Sco Op20b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20b9] move.l $33333333.l, (a0) ----------
static struct Sco Op20b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20ba] move.l ($3333,pc), (a0); =3335 ----------
static struct Sco Op20ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20bb] move.l ($33,pc,d3.w*2), (a0); =35 ----------
static struct Sco Op20bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20bc] move.l #$33333333, (a0) ----------
static struct Sco Op20bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20c0] move.l d0, (a0)+ ----------
static struct Sco Op20c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20d0] move.l (a0), (a0)+ ----------
static struct Sco Op20d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20d8] move.l (a0)+, (a0)+ ----------
static struct Sco Op20d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20df] move.l (a7)+, (a0)+ ----------
static struct Sco Op20df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20e0] move.l -(a0), (a0)+ ----------
static struct Sco Op20e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20e7] move.l -(a7), (a0)+ ----------
static struct Sco Op20e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20e8] move.l ($3333,a0), (a0)+ ----------
static struct Sco Op20e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20f0] move.l ($33,a0,d3.w*2), (a0)+ ----------
static struct Sco Op20f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20f8] move.l $3333.w, (a0)+ ----------
static struct Sco Op20f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20f9] move.l $33333333.l, (a0)+ ----------
static struct Sco Op20f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20fa] move.l ($3333,pc), (a0)+; =3335 ----------
static struct Sco Op20fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20fb] move.l ($33,pc,d3.w*2), (a0)+; =35 ----------
static struct Sco Op20fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [20fc] move.l #$33333333, (a0)+ ----------
static struct Sco Op20fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2100] move.l d0, -(a0) ----------
static struct Sco Op2100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2110] move.l (a0), -(a0) ----------
static struct Sco Op2110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2118] move.l (a0)+, -(a0) ----------
static struct Sco Op2118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [211f] move.l (a7)+, -(a0) ----------
static struct Sco Op211f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2120] move.l -(a0), -(a0) ----------
static struct Sco Op2120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2127] move.l -(a7), -(a0) ----------
static struct Sco Op2127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2128] move.l ($3333,a0), -(a0) ----------
static struct Sco Op2128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2130] move.l ($33,a0,d3.w*2), -(a0) ----------
static struct Sco Op2130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2138] move.l $3333.w, -(a0) ----------
static struct Sco Op2138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2139] move.l $33333333.l, -(a0) ----------
static struct Sco Op2139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [213a] move.l ($3333,pc), -(a0); =3335 ----------
static struct Sco Op213a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [213b] move.l ($33,pc,d3.w*2), -(a0); =35 ----------
static struct Sco Op213b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [213c] move.l #$33333333, -(a0) ----------
static struct Sco Op213c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2140] move.l d0, ($3333,a0) ----------
static struct Sco Op2140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2150] move.l (a0), ($3333,a0) ----------
static struct Sco Op2150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2158] move.l (a0)+, ($3333,a0) ----------
static struct Sco Op2158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [215f] move.l (a7)+, ($3333,a0) ----------
static struct Sco Op215f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2160] move.l -(a0), ($3333,a0) ----------
static struct Sco Op2160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2167] move.l -(a7), ($3333,a0) ----------
static struct Sco Op2167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2168] move.l ($3333,a0), ($3333,a0) ----------
static struct Sco Op2168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2170] move.l ($33,a0,d3.w*2), ($3333,a0) ----------
static struct Sco Op2170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2178] move.l $3333.w, ($3333,a0) ----------
static struct Sco Op2178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2179] move.l $33333333.l, ($3333,a0) ----------
static struct Sco Op2179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [217a] move.l ($3333,pc), ($3333,a0); =3335 ----------
static struct Sco Op217a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [217b] move.l ($33,pc,d3.w*2), ($3333,a0); =35 ----------
static struct Sco Op217b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [217c] move.l #$33333333, ($3333,a0) ----------
static struct Sco Op217c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2180] move.l d0, ($33,a0,d3.w*2) ----------
static struct Sco Op2180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2190] move.l (a0), ($33,a0,d3.w*2) ----------
static struct Sco Op2190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2198] move.l (a0)+, ($33,a0,d3.w*2) ----------
static struct Sco Op2198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [219f] move.l (a7)+, ($33,a0,d3.w*2) ----------
static struct Sco Op219f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21a0] move.l -(a0), ($33,a0,d3.w*2) ----------
static struct Sco Op21a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21a7] move.l -(a7), ($33,a0,d3.w*2) ----------
static struct Sco Op21a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21a8] move.l ($3333,a0), ($33,a0,d3.w*2) ----------
static struct Sco Op21a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21b0] move.l ($33,a0,d3.w*2), ($33,a0,d3.w*2) ----------
static struct Sco Op21b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21b8] move.l $3333.w, ($33,a0,d3.w*2) ----------
static struct Sco Op21b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21b9] move.l $33333333.l, ($33,a0,d3.w*2) ----------
static struct Sco Op21b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 34;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21ba] move.l ($3333,pc), ($33,a0,d3.w*2); =3335 ----------
static struct Sco Op21ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21bb] move.l ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 ----------
static struct Sco Op21bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21bc] move.l #$33333333, ($33,a0,d3.w*2) ----------
static struct Sco Op21bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21c0] move.l d0, $3333.w ----------
static struct Sco Op21c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21d0] move.l (a0), $3333.w ----------
static struct Sco Op21d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21d8] move.l (a0)+, $3333.w ----------
static struct Sco Op21d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21df] move.l (a7)+, $3333.w ----------
static struct Sco Op21df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21e0] move.l -(a0), $3333.w ----------
static struct Sco Op21e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21e7] move.l -(a7), $3333.w ----------
static struct Sco Op21e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21e8] move.l ($3333,a0), $3333.w ----------
static struct Sco Op21e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21f0] move.l ($33,a0,d3.w*2), $3333.w ----------
static struct Sco Op21f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21f8] move.l $3333.w, $3333.w ----------
static struct Sco Op21f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21f9] move.l $33333333.l, $3333.w ----------
static struct Sco Op21f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21fa] move.l ($3333,pc), $3333.w; =3335 ----------
static struct Sco Op21fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21fb] move.l ($33,pc,d3.w*2), $3333.w; =35 ----------
static struct Sco Op21fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [21fc] move.l #$33333333, $3333.w ----------
static struct Sco Op21fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23c0] move.l d0, $33333333.l ----------
static struct Sco Op23c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23d0] move.l (a0), $33333333.l ----------
static struct Sco Op23d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23d8] move.l (a0)+, $33333333.l ----------
static struct Sco Op23d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23df] move.l (a7)+, $33333333.l ----------
static struct Sco Op23df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23e0] move.l -(a0), $33333333.l ----------
static struct Sco Op23e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23e7] move.l -(a7), $33333333.l ----------
static struct Sco Op23e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23e8] move.l ($3333,a0), $33333333.l ----------
static struct Sco Op23e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23f0] move.l ($33,a0,d3.w*2), $33333333.l ----------
static struct Sco Op23f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 34;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23f8] move.l $3333.w, $33333333.l ----------
static struct Sco Op23f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23f9] move.l $33333333.l, $33333333.l ----------
static struct Sco Op23f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 5;
	o.cycles -= 36;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23fa] move.l ($3333,pc), $33333333.l; =3335 ----------
static struct Sco Op23fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23fb] move.l ($33,pc,d3.w*2), $33333333.l; =35 ----------
static struct Sco Op23fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 34;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [23fc] move.l #$33333333, $33333333.l ----------
static struct Sco Op23fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write32(off, val);

	o.pc += 5;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25c0] move.l d0, ($3333,pc); =3335 ----------
static struct Sco Op25c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25d0] move.l (a0), ($3333,pc); =3335 ----------
static struct Sco Op25d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25d8] move.l (a0)+, ($3333,pc); =3335 ----------
static struct Sco Op25d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25df] move.l (a7)+, ($3333,pc); =3335 ----------
static struct Sco Op25df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25e0] move.l -(a0), ($3333,pc); =3335 ----------
static struct Sco Op25e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25e7] move.l -(a7), ($3333,pc); =3335 ----------
static struct Sco Op25e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25e8] move.l ($3333,a0), ($3333,pc); =3337 ----------
static struct Sco Op25e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25f0] move.l ($33,a0,d3.w*2), ($3333,pc); =3337 ----------
static struct Sco Op25f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25f8] move.l $3333.w, ($3333,pc); =3337 ----------
static struct Sco Op25f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25f9] move.l $33333333.l, ($3333,pc); =3339 ----------
static struct Sco Op25f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25fa] move.l ($3333,pc), ($3333,pc); =3337 ----------
static struct Sco Op25fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25fb] move.l ($33,pc,d3.w*2), ($3333,pc); =3337 ----------
static struct Sco Op25fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [25fc] move.l #$33333333, ($3333,pc); =3339 ----------
static struct Sco Op25fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27c0] move.l d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op27c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27d0] move.l (a0), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op27d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27d8] move.l (a0)+, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op27d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27df] move.l (a7)+, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op27df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27e0] move.l -(a0), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op27e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27e7] move.l -(a7), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op27e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27e8] move.l ($3333,a0), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op27e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27f0] move.l ($33,a0,d3.w*2), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op27f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27f8] move.l $3333.w, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op27f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27f9] move.l $33333333.l, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op27f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 34;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27fa] move.l ($3333,pc), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op27fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27fb] move.l ($33,pc,d3.w*2), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op27fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [27fc] move.l #$33333333, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op27fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, val);

	o.pc += 4;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ec0] move.l d0, (a7)+ ----------
static struct Sco Op2ec0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ed0] move.l (a0), (a7)+ ----------
static struct Sco Op2ed0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ed8] move.l (a0)+, (a7)+ ----------
static struct Sco Op2ed8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2edf] move.l (a7)+, (a7)+ ----------
static struct Sco Op2edf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ee0] move.l -(a0), (a7)+ ----------
static struct Sco Op2ee0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ee7] move.l -(a7), (a7)+ ----------
static struct Sco Op2ee7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ee8] move.l ($3333,a0), (a7)+ ----------
static struct Sco Op2ee8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ef0] move.l ($33,a0,d3.w*2), (a7)+ ----------
static struct Sco Op2ef0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ef8] move.l $3333.w, (a7)+ ----------
static struct Sco Op2ef8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2ef9] move.l $33333333.l, (a7)+ ----------
static struct Sco Op2ef9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2efa] move.l ($3333,pc), (a7)+; =3335 ----------
static struct Sco Op2efa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2efb] move.l ($33,pc,d3.w*2), (a7)+; =35 ----------
static struct Sco Op2efb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2efc] move.l #$33333333, (a7)+ ----------
static struct Sco Op2efc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f00] move.l d0, -(a7) ----------
static struct Sco Op2f00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f10] move.l (a0), -(a7) ----------
static struct Sco Op2f10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f18] move.l (a0)+, -(a7) ----------
static struct Sco Op2f18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f1f] move.l (a7)+, -(a7) ----------
static struct Sco Op2f1f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f20] move.l -(a0), -(a7) ----------
static struct Sco Op2f20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f27] move.l -(a7), -(a7) ----------
static struct Sco Op2f27(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f28] move.l ($3333,a0), -(a7) ----------
static struct Sco Op2f28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f30] move.l ($33,a0,d3.w*2), -(a7) ----------
static struct Sco Op2f30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f38] move.l $3333.w, -(a7) ----------
static struct Sco Op2f38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f39] move.l $33333333.l, -(a7) ----------
static struct Sco Op2f39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f3a] move.l ($3333,pc), -(a7); =3335 ----------
static struct Sco Op2f3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f3b] move.l ($33,pc,d3.w*2), -(a7); =35 ----------
static struct Sco Op2f3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 2;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [2f3c] move.l #$33333333, -(a7) ----------
static struct Sco Op2f3c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write32(off, val);

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3000] move.w d0, d0 ----------
static struct Sco Op3000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3010] move.w (a0), d0 ----------
static struct Sco Op3010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3018] move.w (a0)+, d0 ----------
static struct Sco Op3018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [301f] move.w (a7)+, d0 ----------
static struct Sco Op301f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3020] move.w -(a0), d0 ----------
static struct Sco Op3020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3027] move.w -(a7), d0 ----------
static struct Sco Op3027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3028] move.w ($3333,a0), d0 ----------
static struct Sco Op3028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3030] move.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Op3030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3038] move.w $3333.w, d0 ----------
static struct Sco Op3038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3039] move.w $33333333.l, d0 ----------
static struct Sco Op3039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [303a] move.w ($3333,pc), d0; =3335 ----------
static struct Sco Op303a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [303b] move.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op303b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [303c] move.w #$3333, d0 ----------
static struct Sco Op303c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3040] movea.w d0, a0 ----------
static struct Sco Op3040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3050] movea.w (a0), a0 ----------
static struct Sco Op3050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3058] movea.w (a0)+, a0 ----------
static struct Sco Op3058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [305f] movea.w (a7)+, a0 ----------
static struct Sco Op305f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3060] movea.w -(a0), a0 ----------
static struct Sco Op3060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3067] movea.w -(a7), a0 ----------
static struct Sco Op3067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3068] movea.w ($3333,a0), a0 ----------
static struct Sco Op3068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3070] movea.w ($33,a0,d3.w*2), a0 ----------
static struct Sco Op3070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3078] movea.w $3333.w, a0 ----------
static struct Sco Op3078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3079] movea.w $33333333.l, a0 ----------
static struct Sco Op3079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [307a] movea.w ($3333,pc), a0; =3335 ----------
static struct Sco Op307a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [307b] movea.w ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Op307b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [307c] movea.w #$3333, a0 ----------
static struct Sco Op307c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3080] move.w d0, (a0) ----------
static struct Sco Op3080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3090] move.w (a0), (a0) ----------
static struct Sco Op3090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3098] move.w (a0)+, (a0) ----------
static struct Sco Op3098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [309f] move.w (a7)+, (a0) ----------
static struct Sco Op309f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30a0] move.w -(a0), (a0) ----------
static struct Sco Op30a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30a7] move.w -(a7), (a0) ----------
static struct Sco Op30a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30a8] move.w ($3333,a0), (a0) ----------
static struct Sco Op30a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30b0] move.w ($33,a0,d3.w*2), (a0) ----------
static struct Sco Op30b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30b8] move.w $3333.w, (a0) ----------
static struct Sco Op30b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30b9] move.w $33333333.l, (a0) ----------
static struct Sco Op30b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30ba] move.w ($3333,pc), (a0); =3335 ----------
static struct Sco Op30ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30bb] move.w ($33,pc,d3.w*2), (a0); =35 ----------
static struct Sco Op30bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30bc] move.w #$3333, (a0) ----------
static struct Sco Op30bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30c0] move.w d0, (a0)+ ----------
static struct Sco Op30c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30d0] move.w (a0), (a0)+ ----------
static struct Sco Op30d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30d8] move.w (a0)+, (a0)+ ----------
static struct Sco Op30d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30df] move.w (a7)+, (a0)+ ----------
static struct Sco Op30df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30e0] move.w -(a0), (a0)+ ----------
static struct Sco Op30e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30e7] move.w -(a7), (a0)+ ----------
static struct Sco Op30e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30e8] move.w ($3333,a0), (a0)+ ----------
static struct Sco Op30e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30f0] move.w ($33,a0,d3.w*2), (a0)+ ----------
static struct Sco Op30f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30f8] move.w $3333.w, (a0)+ ----------
static struct Sco Op30f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30f9] move.w $33333333.l, (a0)+ ----------
static struct Sco Op30f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30fa] move.w ($3333,pc), (a0)+; =3335 ----------
static struct Sco Op30fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30fb] move.w ($33,pc,d3.w*2), (a0)+; =35 ----------
static struct Sco Op30fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [30fc] move.w #$3333, (a0)+ ----------
static struct Sco Op30fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a0)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3100] move.w d0, -(a0) ----------
static struct Sco Op3100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3110] move.w (a0), -(a0) ----------
static struct Sco Op3110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3118] move.w (a0)+, -(a0) ----------
static struct Sco Op3118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [311f] move.w (a7)+, -(a0) ----------
static struct Sco Op311f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3120] move.w -(a0), -(a0) ----------
static struct Sco Op3120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3127] move.w -(a7), -(a0) ----------
static struct Sco Op3127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3128] move.w ($3333,a0), -(a0) ----------
static struct Sco Op3128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3130] move.w ($33,a0,d3.w*2), -(a0) ----------
static struct Sco Op3130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3138] move.w $3333.w, -(a0) ----------
static struct Sco Op3138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3139] move.w $33333333.l, -(a0) ----------
static struct Sco Op3139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [313a] move.w ($3333,pc), -(a0); =3335 ----------
static struct Sco Op313a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [313b] move.w ($33,pc,d3.w*2), -(a0); =35 ----------
static struct Sco Op313b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [313c] move.w #$3333, -(a0) ----------
static struct Sco Op313c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3140] move.w d0, ($3333,a0) ----------
static struct Sco Op3140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3150] move.w (a0), ($3333,a0) ----------
static struct Sco Op3150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3158] move.w (a0)+, ($3333,a0) ----------
static struct Sco Op3158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [315f] move.w (a7)+, ($3333,a0) ----------
static struct Sco Op315f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3160] move.w -(a0), ($3333,a0) ----------
static struct Sco Op3160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3167] move.w -(a7), ($3333,a0) ----------
static struct Sco Op3167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3168] move.w ($3333,a0), ($3333,a0) ----------
static struct Sco Op3168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3170] move.w ($33,a0,d3.w*2), ($3333,a0) ----------
static struct Sco Op3170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3178] move.w $3333.w, ($3333,a0) ----------
static struct Sco Op3178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3179] move.w $33333333.l, ($3333,a0) ----------
static struct Sco Op3179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [317a] move.w ($3333,pc), ($3333,a0); =3335 ----------
static struct Sco Op317a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [317b] move.w ($33,pc,d3.w*2), ($3333,a0); =35 ----------
static struct Sco Op317b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [317c] move.w #$3333, ($3333,a0) ----------
static struct Sco Op317c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,a0)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	off = sc->d[off] + (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3180] move.w d0, ($33,a0,d3.w*2) ----------
static struct Sco Op3180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3190] move.w (a0), ($33,a0,d3.w*2) ----------
static struct Sco Op3190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3198] move.w (a0)+, ($33,a0,d3.w*2) ----------
static struct Sco Op3198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [319f] move.w (a7)+, ($33,a0,d3.w*2) ----------
static struct Sco Op319f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31a0] move.w -(a0), ($33,a0,d3.w*2) ----------
static struct Sco Op31a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31a7] move.w -(a7), ($33,a0,d3.w*2) ----------
static struct Sco Op31a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31a8] move.w ($3333,a0), ($33,a0,d3.w*2) ----------
static struct Sco Op31a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31b0] move.w ($33,a0,d3.w*2), ($33,a0,d3.w*2) ----------
static struct Sco Op31b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31b8] move.w $3333.w, ($33,a0,d3.w*2) ----------
static struct Sco Op31b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31b9] move.w $33333333.l, ($33,a0,d3.w*2) ----------
static struct Sco Op31b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31ba] move.w ($3333,pc), ($33,a0,d3.w*2); =3335 ----------
static struct Sco Op31ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31bb] move.w ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 ----------
static struct Sco Op31bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31bc] move.w #$3333, ($33,a0,d3.w*2) ----------
static struct Sco Op31bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		s32 rn = 0;
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31c0] move.w d0, $3333.w ----------
static struct Sco Op31c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31d0] move.w (a0), $3333.w ----------
static struct Sco Op31d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31d8] move.w (a0)+, $3333.w ----------
static struct Sco Op31d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31df] move.w (a7)+, $3333.w ----------
static struct Sco Op31df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31e0] move.w -(a0), $3333.w ----------
static struct Sco Op31e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31e7] move.w -(a7), $3333.w ----------
static struct Sco Op31e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31e8] move.w ($3333,a0), $3333.w ----------
static struct Sco Op31e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31f0] move.w ($33,a0,d3.w*2), $3333.w ----------
static struct Sco Op31f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31f8] move.w $3333.w, $3333.w ----------
static struct Sco Op31f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31f9] move.w $33333333.l, $3333.w ----------
static struct Sco Op31f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[3];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31fa] move.w ($3333,pc), $3333.w; =3335 ----------
static struct Sco Op31fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31fb] move.w ($33,pc,d3.w*2), $3333.w; =35 ----------
static struct Sco Op31fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [31fc] move.w #$3333, $3333.w ----------
static struct Sco Op31fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[2];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33c0] move.w d0, $33333333.l ----------
static struct Sco Op33c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33d0] move.w (a0), $33333333.l ----------
static struct Sco Op33d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33d8] move.w (a0)+, $33333333.l ----------
static struct Sco Op33d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33df] move.w (a7)+, $33333333.l ----------
static struct Sco Op33df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33e0] move.w -(a0), $33333333.l ----------
static struct Sco Op33e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33e7] move.w -(a7), $33333333.l ----------
static struct Sco Op33e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33e8] move.w ($3333,a0), $33333333.l ----------
static struct Sco Op33e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33f0] move.w ($33,a0,d3.w*2), $33333333.l ----------
static struct Sco Op33f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33f8] move.w $3333.w, $33333333.l ----------
static struct Sco Op33f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33f9] move.w $33333333.l, $33333333.l ----------
static struct Sco Op33f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[3] << 16) | o.pc[4];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 5;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33fa] move.w ($3333,pc), $33333333.l; =3335 ----------
static struct Sco Op33fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33fb] move.w ($33,pc,d3.w*2), $33333333.l; =35 ----------
static struct Sco Op33fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [33fc] move.w #$3333, $33333333.l ----------
static struct Sco Op33fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[2] << 16) | o.pc[3];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35c0] move.w d0, ($3333,pc); =3335 ----------
static struct Sco Op35c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35d0] move.w (a0), ($3333,pc); =3335 ----------
static struct Sco Op35d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35d8] move.w (a0)+, ($3333,pc); =3335 ----------
static struct Sco Op35d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35df] move.w (a7)+, ($3333,pc); =3335 ----------
static struct Sco Op35df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35e0] move.w -(a0), ($3333,pc); =3335 ----------
static struct Sco Op35e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35e7] move.w -(a7), ($3333,pc); =3335 ----------
static struct Sco Op35e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35e8] move.w ($3333,a0), ($3333,pc); =3337 ----------
static struct Sco Op35e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35f0] move.w ($33,a0,d3.w*2), ($3333,pc); =3337 ----------
static struct Sco Op35f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35f8] move.w $3333.w, ($3333,pc); =3337 ----------
static struct Sco Op35f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35f9] move.w $33333333.l, ($3333,pc); =3339 ----------
static struct Sco Op35f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 3 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[3]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35fa] move.w ($3333,pc), ($3333,pc); =3337 ----------
static struct Sco Op35fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35fb] move.w ($33,pc,d3.w*2), ($3333,pc); =3337 ----------
static struct Sco Op35fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [35fc] move.w #$3333, ($3333,pc); =3337 ----------
static struct Sco Op35fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 2 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[2]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37c0] move.w d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op37c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37d0] move.w (a0), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op37d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37d8] move.w (a0)+, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op37d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37df] move.w (a7)+, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op37df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37e0] move.w -(a0), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op37e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37e7] move.w -(a7), ($33,pc,d3.w*2); =35 ----------
static struct Sco Op37e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37e8] move.w ($3333,a0), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op37e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37f0] move.w ($33,a0,d3.w*2), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op37f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37f8] move.w $3333.w, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op37f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37f9] move.w $33333333.l, ($33,pc,d3.w*2); =39 ----------
static struct Sco Op37f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[3]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 3 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 4;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37fa] move.w ($3333,pc), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op37fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37fb] move.w ($33,pc,d3.w*2), ($33,pc,d3.w*2); =37 ----------
static struct Sco Op37fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [37fc] move.w #$3333, ($33,pc,d3.w*2); =37 ----------
static struct Sco Op37fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[2]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 2 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ec0] move.w d0, (a7)+ ----------
static struct Sco Op3ec0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ed0] move.w (a0), (a7)+ ----------
static struct Sco Op3ed0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ed8] move.w (a0)+, (a7)+ ----------
static struct Sco Op3ed8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3edf] move.w (a7)+, (a7)+ ----------
static struct Sco Op3edf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ee0] move.w -(a0), (a7)+ ----------
static struct Sco Op3ee0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ee7] move.w -(a7), (a7)+ ----------
static struct Sco Op3ee7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ee8] move.w ($3333,a0), (a7)+ ----------
static struct Sco Op3ee8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ef0] move.w ($33,a0,d3.w*2), (a7)+ ----------
static struct Sco Op3ef0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ef8] move.w $3333.w, (a7)+ ----------
static struct Sco Op3ef8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3ef9] move.w $33333333.l, (a7)+ ----------
static struct Sco Op3ef9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3efa] move.w ($3333,pc), (a7)+; =3335 ----------
static struct Sco Op3efa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3efb] move.w ($33,pc,d3.w*2), (a7)+; =35 ----------
static struct Sco Op3efb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3efc] move.w #$3333, (a7)+ ----------
static struct Sco Op3efc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '(a7)+':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f00] move.w d0, -(a7) ----------
static struct Sco Op3f00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f10] move.w (a0), -(a7) ----------
static struct Sco Op3f10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f18] move.w (a0)+, -(a7) ----------
static struct Sco Op3f18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f1f] move.w (a7)+, -(a7) ----------
static struct Sco Op3f1f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f20] move.w -(a0), -(a7) ----------
static struct Sco Op3f20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f27] move.w -(a7), -(a7) ----------
static struct Sco Op3f27(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f28] move.w ($3333,a0), -(a7) ----------
static struct Sco Op3f28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f30] move.w ($33,a0,d3.w*2), -(a7) ----------
static struct Sco Op3f30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f38] move.w $3333.w, -(a7) ----------
static struct Sco Op3f38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f39] move.w $33333333.l, -(a7) ----------
static struct Sco Op3f39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f3a] move.w ($3333,pc), -(a7); =3335 ----------
static struct Sco Op3f3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f3b] move.w ($33,pc,d3.w*2), -(a7); =35 ----------
static struct Sco Op3f3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [3f3c] move.w #$3333, -(a7) ----------
static struct Sco Op3f3c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaCalc : Get '-(a7)':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);

	o.pc += 2;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40c0] move sr, d0 ----------
static struct Sco Op40c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write val into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val & 0xffff;


	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40d0] move sr, (a0) ----------
static struct Sco Op40d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write val into '(a0)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40d8] move sr, (a0)+ ----------
static struct Sco Op40d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a0)+' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40df] move sr, (a7)+ ----------
static struct Sco Op40df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write val into '(a7)+' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40e0] move sr, -(a0) ----------
static struct Sco Op40e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a0)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40e7] move sr, -(a7) ----------
static struct Sco Op40e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write val into '-(a7)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40e8] move sr, ($3333,a0) ----------
static struct Sco Op40e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,a0)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40f0] move sr, ($33,a0,d3.w*2) ----------
static struct Sco Op40f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write val into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40f8] move sr, $3333.w ----------
static struct Sco Op40f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write val into '$3333.w' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40f9] move sr, $33333333.l ----------
static struct Sco Op40f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write val into '$33333333.l' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40fa] move sr, ($3333,pc); =3335 ----------
static struct Sco Op40fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write val into '($3333,pc)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [40fb] move sr, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op40fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.sr;
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write val into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)val);


	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41d0] lea (a0), a0 ----------
static struct Sco Op41d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	val = o.pc[0] & 0x000f;
	val |= 8; // A0-7
	val = sc->d[val];
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41d8] lea (a0)+, a0 ----------
static struct Sco Op41d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	val = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	val = sc->d[val] - 1;
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41df] lea (a7)+, a0 ----------
static struct Sco Op41df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	val = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	val = sc->d[val] - 2;
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41e0] lea -(a0), a0 ----------
static struct Sco Op41e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	val = o.pc[0] & 0x000f;
	val |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	val = sc->d[val];
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41e7] lea -(a7), a0 ----------
static struct Sco Op41e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	val = o.pc[0] & 0x000f;
	val |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	val = sc->d[val];
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41e8] lea ($3333,a0), a0 ----------
static struct Sco Op41e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	val = o.pc[0] & 0x000f;
	val = sc->d[val] + (s16)o.pc[1]; // Add on offset
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41f0] lea ($33,a0,d3.w*2), a0 ----------
static struct Sco Op41f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	val = o.pc[0] & 0x000f;
	val |= 8; // A0-7
		val = sc->d[val];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		val += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41f8] lea $3333.w, a0 ----------
static struct Sco Op41f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	val = (s16)o.pc[1];
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41f9] lea $33333333.l, a0 ----------
static struct Sco Op41f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	val = (o.pc[1] << 16) | o.pc[2];
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41fa] lea ($3333,pc), a0; =3335 ----------
static struct Sco Op41fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	val = (o.pc + 1 - sc->membase) << 1; // Get PC
	val += (s16)o.pc[1]; // Add on offset
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41fb] lea ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Op41fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		val = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) val = (s16)val; // Rn.w
		val += (s8)ext; // 8-bit signed offset
		val += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [41fc] lea #$33, a0 ----------
static struct Sco Op41fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4200] clr.b d0 ----------
static struct Sco Op4200(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4210] clr.b (a0) ----------
static struct Sco Op4210(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4218] clr.b (a0)+ ----------
static struct Sco Op4218(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [421f] clr.b (a7)+ ----------
static struct Sco Op421f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4220] clr.b -(a0) ----------
static struct Sco Op4220(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4227] clr.b -(a7) ----------
static struct Sco Op4227(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4228] clr.b ($3333,a0) ----------
static struct Sco Op4228(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4230] clr.b ($33,a0,d3.w*2) ----------
static struct Sco Op4230(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4238] clr.b $3333.w ----------
static struct Sco Op4238(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4239] clr.b $33333333.l ----------
static struct Sco Op4239(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [423a] clr.b ($3333,pc); =3335 ----------
static struct Sco Op423a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [423b] clr.b ($33,pc,d3.w*2); =35 ----------
static struct Sco Op423b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4240] clr.w d0 ----------
static struct Sco Op4240(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4250] clr.w (a0) ----------
static struct Sco Op4250(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4258] clr.w (a0)+ ----------
static struct Sco Op4258(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [425f] clr.w (a7)+ ----------
static struct Sco Op425f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4260] clr.w -(a0) ----------
static struct Sco Op4260(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4267] clr.w -(a7) ----------
static struct Sco Op4267(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4268] clr.w ($3333,a0) ----------
static struct Sco Op4268(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4270] clr.w ($33,a0,d3.w*2) ----------
static struct Sco Op4270(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4278] clr.w $3333.w ----------
static struct Sco Op4278(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4279] clr.w $33333333.l ----------
static struct Sco Op4279(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [427a] clr.w ($3333,pc); =3335 ----------
static struct Sco Op427a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [427b] clr.w ($33,pc,d3.w*2); =35 ----------
static struct Sco Op427b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4280] clr.l d0 ----------
static struct Sco Op4280(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4290] clr.l (a0) ----------
static struct Sco Op4290(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4298] clr.l (a0)+ ----------
static struct Sco Op4298(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [429f] clr.l (a7)+ ----------
static struct Sco Op429f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42a0] clr.l -(a0) ----------
static struct Sco Op42a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42a7] clr.l -(a7) ----------
static struct Sco Op42a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42a8] clr.l ($3333,a0) ----------
static struct Sco Op42a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42b0] clr.l ($33,a0,d3.w*2) ----------
static struct Sco Op42b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42b8] clr.l $3333.w ----------
static struct Sco Op42b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42b9] clr.l $33333333.l ----------
static struct Sco Op42b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42ba] clr.l ($3333,pc); =3335 ----------
static struct Sco Op42ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [42bb] clr.l ($33,pc,d3.w*2); =35 ----------
static struct Sco Op42bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}

	// Clear:
	o.sr &= ~0xf;
	o.sr |=  0x4; // NZVC=0100

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4400] neg.b d0 ----------
static struct Sco Op4400(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4410] neg.b (a0) ----------
static struct Sco Op4410(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4418] neg.b (a0)+ ----------
static struct Sco Op4418(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [441f] neg.b (a7)+ ----------
static struct Sco Op441f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4420] neg.b -(a0) ----------
static struct Sco Op4420(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4427] neg.b -(a7) ----------
static struct Sco Op4427(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4428] neg.b ($3333,a0) ----------
static struct Sco Op4428(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4430] neg.b ($33,a0,d3.w*2) ----------
static struct Sco Op4430(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4438] neg.b $3333.w ----------
static struct Sco Op4438(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4439] neg.b $33333333.l ----------
static struct Sco Op4439(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [443a] neg.b ($3333,pc); =3335 ----------
static struct Sco Op443a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [443b] neg.b ($33,pc,d3.w*2); =35 ----------
static struct Sco Op443b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4440] neg.w d0 ----------
static struct Sco Op4440(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4450] neg.w (a0) ----------
static struct Sco Op4450(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4458] neg.w (a0)+ ----------
static struct Sco Op4458(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [445f] neg.w (a7)+ ----------
static struct Sco Op445f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4460] neg.w -(a0) ----------
static struct Sco Op4460(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4467] neg.w -(a7) ----------
static struct Sco Op4467(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4468] neg.w ($3333,a0) ----------
static struct Sco Op4468(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4470] neg.w ($33,a0,d3.w*2) ----------
static struct Sco Op4470(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4478] neg.w $3333.w ----------
static struct Sco Op4478(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4479] neg.w $33333333.l ----------
static struct Sco Op4479(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [447a] neg.w ($3333,pc); =3335 ----------
static struct Sco Op447a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [447b] neg.w ($33,pc,d3.w*2); =35 ----------
static struct Sco Op447b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4480] neg.l d0 ----------
static struct Sco Op4480(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4490] neg.l (a0) ----------
static struct Sco Op4490(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4498] neg.l (a0)+ ----------
static struct Sco Op4498(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [449f] neg.l (a7)+ ----------
static struct Sco Op449f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44a0] neg.l -(a0) ----------
static struct Sco Op44a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44a7] neg.l -(a7) ----------
static struct Sco Op44a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44a8] neg.l ($3333,a0) ----------
static struct Sco Op44a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44b0] neg.l ($33,a0,d3.w*2) ----------
static struct Sco Op44b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44b8] neg.l $3333.w ----------
static struct Sco Op44b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44b9] neg.l $33333333.l ----------
static struct Sco Op44b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44ba] neg.l ($3333,pc); =3335 ----------
static struct Sco Op44ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44bb] neg.l ($33,pc,d3.w*2); =35 ----------
static struct Sco Op44bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	// Neg:
	{
		u32 a = 0, b = val;
		res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C
	}

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44c0] move d0, ccr ----------
static struct Sco Op44c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44d0] move (a0), ccr ----------
static struct Sco Op44d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44d8] move (a0)+, ccr ----------
static struct Sco Op44d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44df] move (a7)+, ccr ----------
static struct Sco Op44df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44e0] move -(a0), ccr ----------
static struct Sco Op44e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 1;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44e7] move -(a7), ccr ----------
static struct Sco Op44e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 1;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44e8] move ($3333,a0), ccr ----------
static struct Sco Op44e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44f0] move ($33,a0,d3.w*2), ccr ----------
static struct Sco Op44f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 2;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44f8] move $3333.w, ccr ----------
static struct Sco Op44f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44f9] move $33333333.l, ccr ----------
static struct Sco Op44f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44fa] move ($3333,pc), ccr; =3335 ----------
static struct Sco Op44fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44fb] move ($33,pc,d3.w*2), ccr; =35 ----------
static struct Sco Op44fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 2;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [44fc] move #$3333, ccr ----------
static struct Sco Op44fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	o.sr = (o.sr & ~0xff) | (val & 0xff);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4600] not.b d0 ----------
static struct Sco Op4600(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4610] not.b (a0) ----------
static struct Sco Op4610(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4618] not.b (a0)+ ----------
static struct Sco Op4618(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [461f] not.b (a7)+ ----------
static struct Sco Op461f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4620] not.b -(a0) ----------
static struct Sco Op4620(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4627] not.b -(a7) ----------
static struct Sco Op4627(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4628] not.b ($3333,a0) ----------
static struct Sco Op4628(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4630] not.b ($33,a0,d3.w*2) ----------
static struct Sco Op4630(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4638] not.b $3333.w ----------
static struct Sco Op4638(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4639] not.b $33333333.l ----------
static struct Sco Op4639(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [463a] not.b ($3333,pc); =3335 ----------
static struct Sco Op463a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [463b] not.b ($33,pc,d3.w*2); =35 ----------
static struct Sco Op463b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	// Not:
	res = ~val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4640] not.w d0 ----------
static struct Sco Op4640(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4650] not.w (a0) ----------
static struct Sco Op4650(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4658] not.w (a0)+ ----------
static struct Sco Op4658(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [465f] not.w (a7)+ ----------
static struct Sco Op465f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4660] not.w -(a0) ----------
static struct Sco Op4660(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4667] not.w -(a7) ----------
static struct Sco Op4667(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4668] not.w ($3333,a0) ----------
static struct Sco Op4668(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4670] not.w ($33,a0,d3.w*2) ----------
static struct Sco Op4670(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4678] not.w $3333.w ----------
static struct Sco Op4678(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4679] not.w $33333333.l ----------
static struct Sco Op4679(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [467a] not.w ($3333,pc); =3335 ----------
static struct Sco Op467a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [467b] not.w ($33,pc,d3.w*2); =35 ----------
static struct Sco Op467b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	// Not:
	res = ~val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4680] not.l d0 ----------
static struct Sco Op4680(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4690] not.l (a0) ----------
static struct Sco Op4690(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4698] not.l (a0)+ ----------
static struct Sco Op4698(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [469f] not.l (a7)+ ----------
static struct Sco Op469f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46a0] not.l -(a0) ----------
static struct Sco Op46a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46a7] not.l -(a7) ----------
static struct Sco Op46a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46a8] not.l ($3333,a0) ----------
static struct Sco Op46a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46b0] not.l ($33,a0,d3.w*2) ----------
static struct Sco Op46b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46b8] not.l $3333.w ----------
static struct Sco Op46b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46b9] not.l $33333333.l ----------
static struct Sco Op46b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46ba] not.l ($3333,pc); =3335 ----------
static struct Sco Op46ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46bb] not.l ($33,pc,d3.w*2); =35 ----------
static struct Sco Op46bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	// Not:
	res = ~val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46c0] move d0, sr ----------
static struct Sco Op46c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	o.sr = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46d0] move (a0), sr ----------
static struct Sco Op46d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46d8] move (a0)+, sr ----------
static struct Sco Op46d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46df] move (a7)+, sr ----------
static struct Sco Op46df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46e0] move -(a0), sr ----------
static struct Sco Op46e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 1;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46e7] move -(a7), sr ----------
static struct Sco Op46e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 1;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46e8] move ($3333,a0), sr ----------
static struct Sco Op46e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46f0] move ($33,a0,d3.w*2), sr ----------
static struct Sco Op46f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 2;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46f8] move $3333.w, sr ----------
static struct Sco Op46f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46f9] move $33333333.l, sr ----------
static struct Sco Op46f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	o.sr = val;

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46fa] move ($3333,pc), sr; =3335 ----------
static struct Sco Op46fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	o.sr = val;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46fb] move ($33,pc,d3.w*2), sr; =35 ----------
static struct Sco Op46fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	o.sr = val;

	o.pc += 2;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [46fc] move #$3333, sr ----------
static struct Sco Op46fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	o.sr = val;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4840] swap d0 ----------
static struct Sco Op4840(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res  = (val & 0x0000ffff) << 16;
	res |= (val & 0xffff0000) >> 16;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4880] ext.w d0 ----------
static struct Sco Op4880(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = (int)(s8)val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4890] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0) ----------
static struct Sco Op4890(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		val = sc->d[15 - i];
	// EaWrite: Write val into '(a0)' (address in addr):
	sc->write16(addr, (u16)val);

		addr += 2; // Post-increment address
		o.cycles -= 4; // Take some cycles
	}

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4898] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0)+ ----------
static struct Sco Op4898(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		val = sc->d[15 - i];
	// EaWrite: Write val into '(a0)+' (address in addr):
	sc->write16(addr, (u16)val);

		addr += 2; // Post-increment address
		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [489f] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a7)+ ----------
static struct Sco Op489f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		val = sc->d[15 - i];
	// EaWrite: Write val into '(a7)+' (address in addr):
	sc->write16(addr, (u16)val);

		addr += 2; // Post-increment address
		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48a0] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a0) ----------
static struct Sco Op48a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 2; // Pre-decrement address
		val = sc->d[15 - i];
	// EaWrite: Write val into '-(a0)' (address in addr):
	sc->write16(addr, (u16)val);

		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48a7] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a7) ----------
static struct Sco Op48a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 2; // Pre-decrement address
		val = sc->d[15 - i];
	// EaWrite: Write val into '-(a7)' (address in addr):
	sc->write16(addr, (u16)val);

		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48c0] ext.l d0 ----------
static struct Sco Op48c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = (int)(s16)val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48d0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0) ----------
static struct Sco Op48d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		val = sc->d[15 - i];
	// EaWrite: Write val into '(a0)' (address in addr):
	sc->write32(addr, val);

		addr += 4; // Post-increment address
		o.cycles -= 8; // Take some cycles
	}

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48d8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0)+ ----------
static struct Sco Op48d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		val = sc->d[15 - i];
	// EaWrite: Write val into '(a0)+' (address in addr):
	sc->write32(addr, val);

		addr += 4; // Post-increment address
		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48df] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a7)+ ----------
static struct Sco Op48df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		val = sc->d[15 - i];
	// EaWrite: Write val into '(a7)+' (address in addr):
	sc->write32(addr, val);

		addr += 4; // Post-increment address
		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48e0] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a0) ----------
static struct Sco Op48e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 4; // Pre-decrement address
		val = sc->d[15 - i];
	// EaWrite: Write val into '-(a0)' (address in addr):
	sc->write32(addr, val);

		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [48e7] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a7) ----------
static struct Sco Op48e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 4; // Pre-decrement address
		val = sc->d[15 - i];
	// EaWrite: Write val into '-(a7)' (address in addr):
	sc->write32(addr, val);

		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a00] tst.b d0 ----------
static struct Sco Op4a00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a10] tst.b (a0) ----------
static struct Sco Op4a10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a18] tst.b (a0)+ ----------
static struct Sco Op4a18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a1f] tst.b (a7)+ ----------
static struct Sco Op4a1f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a20] tst.b -(a0) ----------
static struct Sco Op4a20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a27] tst.b -(a7) ----------
static struct Sco Op4a27(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a28] tst.b ($3333,a0) ----------
static struct Sco Op4a28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a30] tst.b ($33,a0,d3.w*2) ----------
static struct Sco Op4a30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a38] tst.b $3333.w ----------
static struct Sco Op4a38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a39] tst.b $33333333.l ----------
static struct Sco Op4a39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s8)sc->read8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a3a] tst.b ($3333,pc); =3335 ----------
static struct Sco Op4a3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a3b] tst.b ($33,pc,d3.w*2); =35 ----------
static struct Sco Op4a3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s8)sc->fetch8(off);

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a3c] tst.b #$33 ----------
static struct Sco Op4a3c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33' into val:
	val = (s8)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a40] tst.w d0 ----------
static struct Sco Op4a40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a50] tst.w (a0) ----------
static struct Sco Op4a50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a58] tst.w (a0)+ ----------
static struct Sco Op4a58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a5f] tst.w (a7)+ ----------
static struct Sco Op4a5f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a60] tst.w -(a0) ----------
static struct Sco Op4a60(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a67] tst.w -(a7) ----------
static struct Sco Op4a67(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a68] tst.w ($3333,a0) ----------
static struct Sco Op4a68(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a70] tst.w ($33,a0,d3.w*2) ----------
static struct Sco Op4a70(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a78] tst.w $3333.w ----------
static struct Sco Op4a78(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a79] tst.w $33333333.l ----------
static struct Sco Op4a79(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = (s16)sc->read16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a7a] tst.w ($3333,pc); =3335 ----------
static struct Sco Op4a7a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a7b] tst.w ($33,pc,d3.w*2); =35 ----------
static struct Sco Op4a7b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = (s16)sc->fetch16(off);

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a7c] tst.w #$33 ----------
static struct Sco Op4a7c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	res = val;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a80] tst.l d0 ----------
static struct Sco Op4a80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a90] tst.l (a0) ----------
static struct Sco Op4a90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a98] tst.l (a0)+ ----------
static struct Sco Op4a98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4a9f] tst.l (a7)+ ----------
static struct Sco Op4a9f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4aa0] tst.l -(a0) ----------
static struct Sco Op4aa0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4aa7] tst.l -(a7) ----------
static struct Sco Op4aa7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4aa8] tst.l ($3333,a0) ----------
static struct Sco Op4aa8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ab0] tst.l ($33,a0,d3.w*2) ----------
static struct Sco Op4ab0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ab8] tst.l $3333.w ----------
static struct Sco Op4ab8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ab9] tst.l $33333333.l ----------
static struct Sco Op4ab9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into val:
	val = sc->read32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4aba] tst.l ($3333,pc); =3335 ----------
static struct Sco Op4aba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4abb] tst.l ($33,pc,d3.w*2); =35 ----------
static struct Sco Op4abb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into val:
	val = sc->fetch32(off);

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4abc] tst.l #$33 ----------
static struct Sco Op4abc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4c90] movem.w (a0), d0-d1/d4-d5/a0-a1/a4-a5 ----------
static struct Sco Op4c90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
	// Copy memory to register:
	// EaRead : Read '(a0)' into val:
	val = (s16)sc->read16(addr);

		sc->d[i] = val;
		addr += 2; // Post-increment address
		o.cycles -= 4; // Take some cycles
	}

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4c98] movem.w (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 ----------
static struct Sco Op4c98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
	// Copy memory to register:
	// EaRead : Read '(a0)+' into val:
	val = (s16)sc->read16(addr);

		sc->d[i] = val;
		addr += 2; // Post-increment address
		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4c9f] movem.w (a7)+, d0-d1/d4-d5/a0-a1/a4-a5 ----------
static struct Sco Op4c9f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
	// Copy memory to register:
	// EaRead : Read '(a7)+' into val:
	val = (s16)sc->read16(addr);

		sc->d[i] = val;
		addr += 2; // Post-increment address
		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ca0] movem.w -(a0), d2-d3/d6-d7/a2-a3/a6-a7 ----------
static struct Sco Op4ca0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 2; // Pre-decrement address
	// Copy memory to register:
	// EaRead : Read '-(a0)' into val:
	val = (s16)sc->read16(addr);

		sc->d[i] = val;
		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ca7] movem.w -(a7), d2-d3/d6-d7/a2-a3/a6-a7 ----------
static struct Sco Op4ca7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 2; // Pre-decrement address
	// Copy memory to register:
	// EaRead : Read '-(a7)' into val:
	val = (s16)sc->read16(addr);

		sc->d[i] = val;
		o.cycles -= 4; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4cd0] movem.l (a0), d0-d1/d4-d5/a0-a1/a4-a5 ----------
static struct Sco Op4cd0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
	// Copy memory to register:
	// EaRead : Read '(a0)' into val:
	val = sc->read32(addr);

		sc->d[i] = val;
		addr += 4; // Post-increment address
		o.cycles -= 8; // Take some cycles
	}

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4cd8] movem.l (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 ----------
static struct Sco Op4cd8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
	// Copy memory to register:
	// EaRead : Read '(a0)+' into val:
	val = sc->read32(addr);

		sc->d[i] = val;
		addr += 4; // Post-increment address
		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4cdf] movem.l (a7)+, d0-d1/d4-d5/a0-a1/a4-a5 ----------
static struct Sco Op4cdf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
	// Copy memory to register:
	// EaRead : Read '(a7)+' into val:
	val = sc->read32(addr);

		sc->d[i] = val;
		addr += 4; // Post-increment address
		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ce0] movem.l -(a0), d2-d3/d6-d7/a2-a3/a6-a7 ----------
static struct Sco Op4ce0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 4; // Pre-decrement address
	// Copy memory to register:
	// EaRead : Read '-(a0)' into val:
	val = sc->read32(addr);

		sc->d[i] = val;
		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ce7] movem.l -(a7), d2-d3/d6-d7/a2-a3/a6-a7 ----------
static struct Sco Op4ce7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 mask = o.pc[1]; // register mask
	u32 addr = 0; // Address value
	int i = 0;

	// Get the address into addr:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into addr:
	addr = sc->d[off];

	for (i = 0; i < 16; i++)
	{
		if (((mask >> i) & 1) == 0) continue;
		addr -= 4; // Pre-decrement address
	// Copy memory to register:
	// EaRead : Read '-(a7)' into val:
	val = sc->read32(addr);

		sc->d[i] = val;
		o.cycles -= 8; // Take some cycles
	}

	// Write back address:
	// EaWrite : Write addr into register[off]:
	sc->d[off] = addr;

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e50] link a0,#$3333 ----------
static struct Sco Op4e50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get An
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	off = (sc->d[0xf] -= 4); // A7 -= 4
	// Write An to Stack
	sc->write32(off, val);

	// Save to An:
	val = off;
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	// Get offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	sc->d[0xf] += val; // Add offset to A7
	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e58] unlk a0 ----------
static struct Sco Op4e58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get An
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Pop An from stack:
	val = sc->read32(off);
	
	sc->d[0xf] = off + 4; // A7
	// An = value from stack:
	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e60] move a0, usp ----------
static struct Sco Op4e60(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	sc->osp = val; // Put in USP

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e68] move usp, a0 ----------
static struct Sco Op4e68(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	off |= 8; // A0-7
	val = sc->osp; // Get from USP

	// EaWrite : Write val into register[off]:
	sc->d[off] = val;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e71] nop ----------
static struct Sco Op4e71(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e73] rte ----------
static struct Sco Op4e73(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Pop SR
	val = (s16)sc->read16(sc->d[0xf]);
	sc->d[0xf] += 2; // Postincrement A7
	o.sr = val;
	// Pop PC:
	{
	u32 tmp = 0;
	tmp = sc->read32(sc->d[0xf]);
	sc->d[0xf] += 4; // Postincrement A7
	o.pc = sc->membase + (tmp >> 1);
	}
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e75] rts ----------
static struct Sco Op4e75(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Pop PC:
	{
	u32 tmp = 0;
	tmp = sc->read32(sc->d[0xf]);
	sc->d[0xf] += 4; // Postincrement A7
	o.pc = sc->membase + (tmp >> 1);
	}
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e77] rtr ----------
static struct Sco Op4e77(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Pop SR
	val = (s16)sc->read16(sc->d[0xf]);
	sc->d[0xf] += 2; // Postincrement A7
	o.sr = (o.sr & ~0xff) | (val & 0xff);
	// Pop PC:
	{
	u32 tmp = 0;
	tmp = sc->read32(sc->d[0xf]);
	sc->d[0xf] += 4; // Postincrement A7
	o.pc = sc->membase + (tmp >> 1);
	}
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e90] jsr (a0) ----------
static struct Sco Op4e90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e98] jsr (a0)+ ----------
static struct Sco Op4e98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4e9f] jsr (a7)+ ----------
static struct Sco Op4e9f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ea0] jsr -(a0) ----------
static struct Sco Op4ea0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ea7] jsr -(a7) ----------
static struct Sco Op4ea7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ea8] jsr ($3333,a0) ----------
static struct Sco Op4ea8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 2 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4eb0] jsr ($33,a0,d3.w*2) ----------
static struct Sco Op4eb0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 2 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4eb8] jsr $3333.w ----------
static struct Sco Op4eb8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 2 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4eb9] jsr $33333333.l ----------
static struct Sco Op4eb9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 3 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 34;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4eba] jsr ($3333,pc); =3335 ----------
static struct Sco Op4eba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 2 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 30;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ebb] jsr ($33,pc,d3.w*2); =35 ----------
static struct Sco Op4ebb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}

	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 2 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 32;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ebc] jsr #$33 ----------
static struct Sco Op4ebc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;


	// Jsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ed0] jmp (a0) ----------
static struct Sco Op4ed0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ed8] jmp (a0)+ ----------
static struct Sco Op4ed8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4edf] jmp (a7)+ ----------
static struct Sco Op4edf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ee0] jmp -(a0) ----------
static struct Sco Op4ee0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ee7] jmp -(a7) ----------
static struct Sco Op4ee7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ee8] jmp ($3333,a0) ----------
static struct Sco Op4ee8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ef0] jmp ($33,a0,d3.w*2) ----------
static struct Sco Op4ef0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ef8] jmp $3333.w ----------
static struct Sco Op4ef8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4ef9] jmp $33333333.l ----------
static struct Sco Op4ef9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4efa] jmp ($3333,pc); =3335 ----------
static struct Sco Op4efa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4efb] jmp ($33,pc,d3.w*2); =35 ----------
static struct Sco Op4efb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}

	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [4efc] jmp #$33 ----------
static struct Sco Op4efc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;


	// Get new PC from 'off'
	o.pc = sc->membase + (off >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5000] addq.b #8, d0 ----------
static struct Sco Op5000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5008] addq.b #8, a0 ----------
static struct Sco Op5008(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = 8;
	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5010] addq.b #8, (a0) ----------
static struct Sco Op5010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5018] addq.b #8, (a0)+ ----------
static struct Sco Op5018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5020] addq.b #8, -(a0) ----------
static struct Sco Op5020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5028] addq.b #8, ($3333,a0) ----------
static struct Sco Op5028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5030] addq.b #8, ($33,a0,d3.w*2) ----------
static struct Sco Op5030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5038] addq.b #8, $3333.w ----------
static struct Sco Op5038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5039] addq.b #8, $33333333.l ----------
static struct Sco Op5039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [503a] addq.b #8, ($3333,pc); =3335 ----------
static struct Sco Op503a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [503b] addq.b #8, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op503b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	b = 8;
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5040] addq.w #8, d0 ----------
static struct Sco Op5040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5050] addq.w #8, (a0) ----------
static struct Sco Op5050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5058] addq.w #8, (a0)+ ----------
static struct Sco Op5058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5060] addq.w #8, -(a0) ----------
static struct Sco Op5060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5068] addq.w #8, ($3333,a0) ----------
static struct Sco Op5068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5070] addq.w #8, ($33,a0,d3.w*2) ----------
static struct Sco Op5070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5078] addq.w #8, $3333.w ----------
static struct Sco Op5078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5079] addq.w #8, $33333333.l ----------
static struct Sco Op5079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [507a] addq.w #8, ($3333,pc); =3335 ----------
static struct Sco Op507a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [507b] addq.w #8, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op507b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	b = 8;
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5080] addq.l #8, d0 ----------
static struct Sco Op5080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5090] addq.l #8, (a0) ----------
static struct Sco Op5090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5098] addq.l #8, (a0)+ ----------
static struct Sco Op5098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50a0] addq.l #8, -(a0) ----------
static struct Sco Op50a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50a8] addq.l #8, ($3333,a0) ----------
static struct Sco Op50a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50b0] addq.l #8, ($33,a0,d3.w*2) ----------
static struct Sco Op50b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50b8] addq.l #8, $3333.w ----------
static struct Sco Op50b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50b9] addq.l #8, $33333333.l ----------
static struct Sco Op50b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50ba] addq.l #8, ($3333,pc); =3335 ----------
static struct Sco Op50ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50bb] addq.l #8, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op50bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	b = 8;
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50c0] st d0 ----------
static struct Sco Op50c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50d0] st (a0) ----------
static struct Sco Op50d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50d8] st (a0)+ ----------
static struct Sco Op50d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50df] st (a7)+ ----------
static struct Sco Op50df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50e0] st -(a0) ----------
static struct Sco Op50e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50e7] st -(a7) ----------
static struct Sco Op50e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50e8] st ($3333,a0) ----------
static struct Sco Op50e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50f0] st ($33,a0,d3.w*2) ----------
static struct Sco Op50f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50f8] st $3333.w ----------
static struct Sco Op50f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50f9] st $33333333.l ----------
static struct Sco Op50f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50fa] st ($3333,pc); =3335 ----------
static struct Sco Op50fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [50fb] st ($33,pc,d3.w*2); =35 ----------
static struct Sco Op50fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5100] subq.b #8, d0 ----------
static struct Sco Op5100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5108] subq.b #8, a0 ----------
static struct Sco Op5108(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = 8;
	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5110] subq.b #8, (a0) ----------
static struct Sco Op5110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5118] subq.b #8, (a0)+ ----------
static struct Sco Op5118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5120] subq.b #8, -(a0) ----------
static struct Sco Op5120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5128] subq.b #8, ($3333,a0) ----------
static struct Sco Op5128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5130] subq.b #8, ($33,a0,d3.w*2) ----------
static struct Sco Op5130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5138] subq.b #8, $3333.w ----------
static struct Sco Op5138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5139] subq.b #8, $33333333.l ----------
static struct Sco Op5139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [513a] subq.b #8, ($3333,pc); =3335 ----------
static struct Sco Op513a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [513b] subq.b #8, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op513b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	b = 8;
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5140] subq.w #8, d0 ----------
static struct Sco Op5140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5150] subq.w #8, (a0) ----------
static struct Sco Op5150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5158] subq.w #8, (a0)+ ----------
static struct Sco Op5158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5160] subq.w #8, -(a0) ----------
static struct Sco Op5160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5168] subq.w #8, ($3333,a0) ----------
static struct Sco Op5168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5170] subq.w #8, ($33,a0,d3.w*2) ----------
static struct Sco Op5170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5178] subq.w #8, $3333.w ----------
static struct Sco Op5178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5179] subq.w #8, $33333333.l ----------
static struct Sco Op5179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [517a] subq.w #8, ($3333,pc); =3335 ----------
static struct Sco Op517a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [517b] subq.w #8, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op517b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	b = 8;
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5180] subq.l #8, d0 ----------
static struct Sco Op5180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5190] subq.l #8, (a0) ----------
static struct Sco Op5190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5198] subq.l #8, (a0)+ ----------
static struct Sco Op5198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51a0] subq.l #8, -(a0) ----------
static struct Sco Op51a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51a8] subq.l #8, ($3333,a0) ----------
static struct Sco Op51a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51b0] subq.l #8, ($33,a0,d3.w*2) ----------
static struct Sco Op51b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51b8] subq.l #8, $3333.w ----------
static struct Sco Op51b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51b9] subq.l #8, $33333333.l ----------
static struct Sco Op51b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51ba] subq.l #8, ($3333,pc); =3335 ----------
static struct Sco Op51ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51bb] subq.l #8, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op51bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	b = 8;
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51c0] sf d0 ----------
static struct Sco Op51c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51c8] dbra d0, 3335 ----------
static struct Sco Op51c8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int end = 0;

	// Decrement Dn.w:
	off = o.pc[0] & 7;
	val = (sc->d[off] - 1) & 0xffff;
	if (val == 0xffff) end = 1;
	sc->d[off] &= ~0xffff;
	sc->d[off] |= val;

	if (end)
	{
		o.cycles -= 12;
		o.pc += 2;
	}
	else
	{
		// Get Branch offset:
		val = (s16)o.pc[1];
		o.pc += 1 + (val >> 1);
		o.cycles -= 10;
	}

	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51d0] sf (a0) ----------
static struct Sco Op51d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51d8] sf (a0)+ ----------
static struct Sco Op51d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51df] sf (a7)+ ----------
static struct Sco Op51df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51e0] sf -(a0) ----------
static struct Sco Op51e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51e7] sf -(a7) ----------
static struct Sco Op51e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51e8] sf ($3333,a0) ----------
static struct Sco Op51e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51f0] sf ($33,a0,d3.w*2) ----------
static struct Sco Op51f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51f8] sf $3333.w ----------
static struct Sco Op51f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51f9] sf $33333333.l ----------
static struct Sco Op51f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51fa] sf ($3333,pc); =3335 ----------
static struct Sco Op51fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [51fb] sf ($33,pc,d3.w*2); =35 ----------
static struct Sco Op51fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52c0] shi d0 ----------
static struct Sco Op52c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52d0] shi (a0) ----------
static struct Sco Op52d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52d8] shi (a0)+ ----------
static struct Sco Op52d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52df] shi (a7)+ ----------
static struct Sco Op52df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52e0] shi -(a0) ----------
static struct Sco Op52e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52e7] shi -(a7) ----------
static struct Sco Op52e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52e8] shi ($3333,a0) ----------
static struct Sco Op52e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52f0] shi ($33,a0,d3.w*2) ----------
static struct Sco Op52f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52f8] shi $3333.w ----------
static struct Sco Op52f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52f9] shi $33333333.l ----------
static struct Sco Op52f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52fa] shi ($3333,pc); =3335 ----------
static struct Sco Op52fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [52fb] shi ($33,pc,d3.w*2); =35 ----------
static struct Sco Op52fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 5) == 0) // hs: ~C and ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53c0] sls d0 ----------
static struct Sco Op53c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53d0] sls (a0) ----------
static struct Sco Op53d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53d8] sls (a0)+ ----------
static struct Sco Op53d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53df] sls (a7)+ ----------
static struct Sco Op53df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53e0] sls -(a0) ----------
static struct Sco Op53e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53e7] sls -(a7) ----------
static struct Sco Op53e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53e8] sls ($3333,a0) ----------
static struct Sco Op53e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53f0] sls ($33,a0,d3.w*2) ----------
static struct Sco Op53f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53f8] sls $3333.w ----------
static struct Sco Op53f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53f9] sls $33333333.l ----------
static struct Sco Op53f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53fa] sls ($3333,pc); =3335 ----------
static struct Sco Op53fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [53fb] sls ($33,pc,d3.w*2); =35 ----------
static struct Sco Op53fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 5)       // ls:  C or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54c0] scc d0 ----------
static struct Sco Op54c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54d0] scc (a0) ----------
static struct Sco Op54d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54d8] scc (a0)+ ----------
static struct Sco Op54d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54df] scc (a7)+ ----------
static struct Sco Op54df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54e0] scc -(a0) ----------
static struct Sco Op54e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54e7] scc -(a7) ----------
static struct Sco Op54e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54e8] scc ($3333,a0) ----------
static struct Sco Op54e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54f0] scc ($33,a0,d3.w*2) ----------
static struct Sco Op54f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54f8] scc $3333.w ----------
static struct Sco Op54f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54f9] scc $33333333.l ----------
static struct Sco Op54f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54fa] scc ($3333,pc); =3335 ----------
static struct Sco Op54fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [54fb] scc ($33,pc,d3.w*2); =35 ----------
static struct Sco Op54fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 1) == 0) // cc: ~C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55c0] scs d0 ----------
static struct Sco Op55c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55d0] scs (a0) ----------
static struct Sco Op55d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55d8] scs (a0)+ ----------
static struct Sco Op55d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55df] scs (a7)+ ----------
static struct Sco Op55df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55e0] scs -(a0) ----------
static struct Sco Op55e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55e7] scs -(a7) ----------
static struct Sco Op55e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55e8] scs ($3333,a0) ----------
static struct Sco Op55e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55f0] scs ($33,a0,d3.w*2) ----------
static struct Sco Op55f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55f8] scs $3333.w ----------
static struct Sco Op55f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55f9] scs $33333333.l ----------
static struct Sco Op55f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55fa] scs ($3333,pc); =3335 ----------
static struct Sco Op55fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [55fb] scs ($33,pc,d3.w*2); =35 ----------
static struct Sco Op55fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 1)       // cs:  C
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56c0] sne d0 ----------
static struct Sco Op56c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56d0] sne (a0) ----------
static struct Sco Op56d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56d8] sne (a0)+ ----------
static struct Sco Op56d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56df] sne (a7)+ ----------
static struct Sco Op56df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56e0] sne -(a0) ----------
static struct Sco Op56e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56e7] sne -(a7) ----------
static struct Sco Op56e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56e8] sne ($3333,a0) ----------
static struct Sco Op56e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56f0] sne ($33,a0,d3.w*2) ----------
static struct Sco Op56f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56f8] sne $3333.w ----------
static struct Sco Op56f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56f9] sne $33333333.l ----------
static struct Sco Op56f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56fa] sne ($3333,pc); =3335 ----------
static struct Sco Op56fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [56fb] sne ($33,pc,d3.w*2); =35 ----------
static struct Sco Op56fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 4) == 0) // ne: ~Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57c0] seq d0 ----------
static struct Sco Op57c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57d0] seq (a0) ----------
static struct Sco Op57d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57d8] seq (a0)+ ----------
static struct Sco Op57d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57df] seq (a7)+ ----------
static struct Sco Op57df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57e0] seq -(a0) ----------
static struct Sco Op57e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57e7] seq -(a7) ----------
static struct Sco Op57e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57e8] seq ($3333,a0) ----------
static struct Sco Op57e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57f0] seq ($33,a0,d3.w*2) ----------
static struct Sco Op57f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57f8] seq $3333.w ----------
static struct Sco Op57f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57f9] seq $33333333.l ----------
static struct Sco Op57f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57fa] seq ($3333,pc); =3335 ----------
static struct Sco Op57fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [57fb] seq ($33,pc,d3.w*2); =35 ----------
static struct Sco Op57fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 4      ) // eq:  Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58c0] svc d0 ----------
static struct Sco Op58c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58d0] svc (a0) ----------
static struct Sco Op58d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58d8] svc (a0)+ ----------
static struct Sco Op58d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58df] svc (a7)+ ----------
static struct Sco Op58df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58e0] svc -(a0) ----------
static struct Sco Op58e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58e7] svc -(a7) ----------
static struct Sco Op58e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58e8] svc ($3333,a0) ----------
static struct Sco Op58e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58f0] svc ($33,a0,d3.w*2) ----------
static struct Sco Op58f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58f8] svc $3333.w ----------
static struct Sco Op58f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58f9] svc $33333333.l ----------
static struct Sco Op58f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58fa] svc ($3333,pc); =3335 ----------
static struct Sco Op58fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [58fb] svc ($33,pc,d3.w*2); =35 ----------
static struct Sco Op58fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 2) == 0) // vc: ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59c0] svs d0 ----------
static struct Sco Op59c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59d0] svs (a0) ----------
static struct Sco Op59d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59d8] svs (a0)+ ----------
static struct Sco Op59d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59df] svs (a7)+ ----------
static struct Sco Op59df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59e0] svs -(a0) ----------
static struct Sco Op59e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59e7] svs -(a7) ----------
static struct Sco Op59e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59e8] svs ($3333,a0) ----------
static struct Sco Op59e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59f0] svs ($33,a0,d3.w*2) ----------
static struct Sco Op59f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59f8] svs $3333.w ----------
static struct Sco Op59f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59f9] svs $33333333.l ----------
static struct Sco Op59f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59fa] svs ($3333,pc); =3335 ----------
static struct Sco Op59fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [59fb] svs ($33,pc,d3.w*2); =35 ----------
static struct Sco Op59fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 2      ) // vs:  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ac0] spl d0 ----------
static struct Sco Op5ac0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ad0] spl (a0) ----------
static struct Sco Op5ad0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ad8] spl (a0)+ ----------
static struct Sco Op5ad8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5adf] spl (a7)+ ----------
static struct Sco Op5adf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ae0] spl -(a0) ----------
static struct Sco Op5ae0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ae7] spl -(a7) ----------
static struct Sco Op5ae7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ae8] spl ($3333,a0) ----------
static struct Sco Op5ae8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5af0] spl ($33,a0,d3.w*2) ----------
static struct Sco Op5af0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5af8] spl $3333.w ----------
static struct Sco Op5af8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5af9] spl $33333333.l ----------
static struct Sco Op5af9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5afa] spl ($3333,pc); =3335 ----------
static struct Sco Op5afa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5afb] spl ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5afb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 8) == 0) // pl: ~N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bc0] smi d0 ----------
static struct Sco Op5bc0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bd0] smi (a0) ----------
static struct Sco Op5bd0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bd8] smi (a0)+ ----------
static struct Sco Op5bd8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bdf] smi (a7)+ ----------
static struct Sco Op5bdf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5be0] smi -(a0) ----------
static struct Sco Op5be0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5be7] smi -(a7) ----------
static struct Sco Op5be7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5be8] smi ($3333,a0) ----------
static struct Sco Op5be8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bf0] smi ($33,a0,d3.w*2) ----------
static struct Sco Op5bf0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bf8] smi $3333.w ----------
static struct Sco Op5bf8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bf9] smi $33333333.l ----------
static struct Sco Op5bf9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bfa] smi ($3333,pc); =3335 ----------
static struct Sco Op5bfa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5bfb] smi ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5bfb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ( o.sr & 8      ) // mi:  N
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cc0] sge d0 ----------
static struct Sco Op5cc0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cd0] sge (a0) ----------
static struct Sco Op5cd0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cd8] sge (a0)+ ----------
static struct Sco Op5cd8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cdf] sge (a7)+ ----------
static struct Sco Op5cdf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ce0] sge -(a0) ----------
static struct Sco Op5ce0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ce7] sge -(a7) ----------
static struct Sco Op5ce7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ce8] sge ($3333,a0) ----------
static struct Sco Op5ce8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cf0] sge ($33,a0,d3.w*2) ----------
static struct Sco Op5cf0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cf8] sge $3333.w ----------
static struct Sco Op5cf8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cf9] sge $33333333.l ----------
static struct Sco Op5cf9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cfa] sge ($3333,pc); =3335 ----------
static struct Sco Op5cfa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5cfb] sge ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5cfb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // ge: ~N ~V or N  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5dc0] slt d0 ----------
static struct Sco Op5dc0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5dd0] slt (a0) ----------
static struct Sco Op5dd0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5dd8] slt (a0)+ ----------
static struct Sco Op5dd8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ddf] slt (a7)+ ----------
static struct Sco Op5ddf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5de0] slt -(a0) ----------
static struct Sco Op5de0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5de7] slt -(a7) ----------
static struct Sco Op5de7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5de8] slt ($3333,a0) ----------
static struct Sco Op5de8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5df0] slt ($33,a0,d3.w*2) ----------
static struct Sco Op5df0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5df8] slt $3333.w ----------
static struct Sco Op5df8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5df9] slt $33333333.l ----------
static struct Sco Op5df9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5dfa] slt ($3333,pc); =3335 ----------
static struct Sco Op5dfa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5dfb] slt ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5dfb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // lt: ~N  V or N ~V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e00] addq.b #7, d0 ----------
static struct Sco Op5e00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e08] addq.b #7, a0 ----------
static struct Sco Op5e08(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e10] addq.b #7, (a0) ----------
static struct Sco Op5e10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e18] addq.b #7, (a0)+ ----------
static struct Sco Op5e18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e20] addq.b #7, -(a0) ----------
static struct Sco Op5e20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e28] addq.b #7, ($3333,a0) ----------
static struct Sco Op5e28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e30] addq.b #7, ($33,a0,d3.w*2) ----------
static struct Sco Op5e30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e38] addq.b #7, $3333.w ----------
static struct Sco Op5e38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e39] addq.b #7, $33333333.l ----------
static struct Sco Op5e39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e3a] addq.b #7, ($3333,pc); =3335 ----------
static struct Sco Op5e3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e3b] addq.b #7, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5e3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e40] addq.w #7, d0 ----------
static struct Sco Op5e40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e50] addq.w #7, (a0) ----------
static struct Sco Op5e50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e58] addq.w #7, (a0)+ ----------
static struct Sco Op5e58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e60] addq.w #7, -(a0) ----------
static struct Sco Op5e60(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e68] addq.w #7, ($3333,a0) ----------
static struct Sco Op5e68(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e70] addq.w #7, ($33,a0,d3.w*2) ----------
static struct Sco Op5e70(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e78] addq.w #7, $3333.w ----------
static struct Sco Op5e78(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e79] addq.w #7, $33333333.l ----------
static struct Sco Op5e79(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e7a] addq.w #7, ($3333,pc); =3335 ----------
static struct Sco Op5e7a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e7b] addq.w #7, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5e7b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e80] addq.l #7, d0 ----------
static struct Sco Op5e80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e90] addq.l #7, (a0) ----------
static struct Sco Op5e90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5e98] addq.l #7, (a0)+ ----------
static struct Sco Op5e98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ea0] addq.l #7, -(a0) ----------
static struct Sco Op5ea0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ea8] addq.l #7, ($3333,a0) ----------
static struct Sco Op5ea8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5eb0] addq.l #7, ($33,a0,d3.w*2) ----------
static struct Sco Op5eb0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5eb8] addq.l #7, $3333.w ----------
static struct Sco Op5eb8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5eb9] addq.l #7, $33333333.l ----------
static struct Sco Op5eb9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5eba] addq.l #7, ($3333,pc); =3335 ----------
static struct Sco Op5eba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ebb] addq.l #7, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5ebb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ec0] sgt d0 ----------
static struct Sco Op5ec0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ed0] sgt (a0) ----------
static struct Sco Op5ed0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ed8] sgt (a0)+ ----------
static struct Sco Op5ed8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5edf] sgt (a7)+ ----------
static struct Sco Op5edf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ee0] sgt -(a0) ----------
static struct Sco Op5ee0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ee7] sgt -(a7) ----------
static struct Sco Op5ee7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ee8] sgt ($3333,a0) ----------
static struct Sco Op5ee8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ef0] sgt ($33,a0,d3.w*2) ----------
static struct Sco Op5ef0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ef8] sgt $3333.w ----------
static struct Sco Op5ef8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ef9] sgt $33333333.l ----------
static struct Sco Op5ef9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5efa] sgt ($3333,pc); =3335 ----------
static struct Sco Op5efa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5efb] sgt ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5efb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // gt: ~N ~Z ~V or N ~Z  V
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f00] subq.b #7, d0 ----------
static struct Sco Op5f00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f08] subq.b #7, a0 ----------
static struct Sco Op5f08(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f10] subq.b #7, (a0) ----------
static struct Sco Op5f10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f18] subq.b #7, (a0)+ ----------
static struct Sco Op5f18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f20] subq.b #7, -(a0) ----------
static struct Sco Op5f20(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f28] subq.b #7, ($3333,a0) ----------
static struct Sco Op5f28(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f30] subq.b #7, ($33,a0,d3.w*2) ----------
static struct Sco Op5f30(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f38] subq.b #7, $3333.w ----------
static struct Sco Op5f38(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f39] subq.b #7, $33333333.l ----------
static struct Sco Op5f39(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f3a] subq.b #7, ($3333,pc); =3335 ----------
static struct Sco Op5f3a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f3b] subq.b #7, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5f3b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f40] subq.w #7, d0 ----------
static struct Sco Op5f40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f50] subq.w #7, (a0) ----------
static struct Sco Op5f50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f58] subq.w #7, (a0)+ ----------
static struct Sco Op5f58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f60] subq.w #7, -(a0) ----------
static struct Sco Op5f60(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f68] subq.w #7, ($3333,a0) ----------
static struct Sco Op5f68(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f70] subq.w #7, ($33,a0,d3.w*2) ----------
static struct Sco Op5f70(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f78] subq.w #7, $3333.w ----------
static struct Sco Op5f78(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f79] subq.w #7, $33333333.l ----------
static struct Sco Op5f79(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f7a] subq.w #7, ($3333,pc); =3335 ----------
static struct Sco Op5f7a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f7b] subq.w #7, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5f7b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f80] subq.l #7, d0 ----------
static struct Sco Op5f80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f90] subq.l #7, (a0) ----------
static struct Sco Op5f90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5f98] subq.l #7, (a0)+ ----------
static struct Sco Op5f98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fa0] subq.l #7, -(a0) ----------
static struct Sco Op5fa0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fa8] subq.l #7, ($3333,a0) ----------
static struct Sco Op5fa8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fb0] subq.l #7, ($33,a0,d3.w*2) ----------
static struct Sco Op5fb0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fb8] subq.l #7, $3333.w ----------
static struct Sco Op5fb8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fb9] subq.l #7, $33333333.l ----------
static struct Sco Op5fb9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fba] subq.l #7, ($3333,pc); =3335 ----------
static struct Sco Op5fba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fbb] subq.l #7, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5fbb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	b = (o.pc[0] >> 9) & 7; // Get quick value
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fc0] sle d0 ----------
static struct Sco Op5fc0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
		o.cycles -= 2; // Extra cycles
	}

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fd0] sle (a0) ----------
static struct Sco Op5fd0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fd8] sle (a0)+ ----------
static struct Sco Op5fd8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fdf] sle (a7)+ ----------
static struct Sco Op5fdf(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fe0] sle -(a0) ----------
static struct Sco Op5fe0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fe7] sle -(a7) ----------
static struct Sco Op5fe7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5fe8] sle ($3333,a0) ----------
static struct Sco Op5fe8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ff0] sle ($33,a0,d3.w*2) ----------
static struct Sco Op5ff0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ff8] sle $3333.w ----------
static struct Sco Op5ff8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ff9] sle $33333333.l ----------
static struct Sco Op5ff9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ffa] sle ($3333,pc); =3335 ----------
static struct Sco Op5ffa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [5ffb] sle ($33,pc,d3.w*2); =35 ----------
static struct Sco Op5ffb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Is the condition true?
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // le: ~N  V or N ~V or Z
	{
		res = 0xffffffff;
	}

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6000] bra 3335 ----------
static struct Sco Op6000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Branch, add on val to PC:
	o.pc += 1 + (val >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6001] bra 3 ----------
static struct Sco Op6001(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Branch, add on val to PC:
	o.pc += 1 + (val >> 1);

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [60ff] bra 33333335 ----------
static struct Sco Op60ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Branch, add on val to PC:
	o.pc += 1 + (val >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6100] bsr 3335 ----------
static struct Sco Op6100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Bsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 2 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Add on val to PC:
	o.pc += 1 + (val >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6101] bsr 3 ----------
static struct Sco Op6101(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Bsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 1 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Add on val to PC:
	o.pc += 1 + (val >> 1);

	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [61ff] bsr 33333335 ----------
static struct Sco Op61ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Bsr:
	// Push PC:
	{
	u32 tmp = 0;
	tmp = (o.pc + 3 - sc->membase) << 1;
	// Push tmp onto stack
	sc->d[0xf] -= 4; // Predecrement A7
	sc->write32(sc->d[0xf], tmp);
	}
	// Add on val to PC:
	o.pc += 1 + (val >> 1);

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6200] bhi 3335 ----------
static struct Sco Op6200(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 5) == 0) // bhs: ~C and ~Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6201] bhi 3 ----------
static struct Sco Op6201(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 5) == 0) // bhs: ~C and ~Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [62ff] bhi 33333335 ----------
static struct Sco Op62ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 5) == 0) // bhs: ~C and ~Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6300] bls 3335 ----------
static struct Sco Op6300(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ( o.sr & 5)       // bls:  C or Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6301] bls 3 ----------
static struct Sco Op6301(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ( o.sr & 5)       // bls:  C or Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [63ff] bls 33333335 ----------
static struct Sco Op63ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ( o.sr & 5)       // bls:  C or Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6400] bcc 3335 ----------
static struct Sco Op6400(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 1) == 0) // bcc: ~C
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6401] bcc 3 ----------
static struct Sco Op6401(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 1) == 0) // bcc: ~C
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [64ff] bcc 33333335 ----------
static struct Sco Op64ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 1) == 0) // bcc: ~C
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6500] bcs 3335 ----------
static struct Sco Op6500(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ( o.sr & 1)       // bcs:  C
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6501] bcs 3 ----------
static struct Sco Op6501(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ( o.sr & 1)       // bcs:  C
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [65ff] bcs 33333335 ----------
static struct Sco Op65ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ( o.sr & 1)       // bcs:  C
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6600] bne 3335 ----------
static struct Sco Op6600(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 4) == 0) // bne: ~Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6601] bne 3 ----------
static struct Sco Op6601(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 4) == 0) // bne: ~Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [66ff] bne 33333335 ----------
static struct Sco Op66ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 4) == 0) // bne: ~Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6700] beq 3335 ----------
static struct Sco Op6700(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ( o.sr & 4      ) // beq:  Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6701] beq 3 ----------
static struct Sco Op6701(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ( o.sr & 4      ) // beq:  Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [67ff] beq 33333335 ----------
static struct Sco Op67ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ( o.sr & 4      ) // beq:  Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6800] bvc 3335 ----------
static struct Sco Op6800(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 2) == 0) // bvc: ~V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6801] bvc 3 ----------
static struct Sco Op6801(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 2) == 0) // bvc: ~V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [68ff] bvc 33333335 ----------
static struct Sco Op68ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 2) == 0) // bvc: ~V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6900] bvs 3335 ----------
static struct Sco Op6900(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ( o.sr & 2      ) // bvs:  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6901] bvs 3 ----------
static struct Sco Op6901(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ( o.sr & 2      ) // bvs:  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [69ff] bvs 33333335 ----------
static struct Sco Op69ff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ( o.sr & 2      ) // bvs:  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6a00] bpl 3335 ----------
static struct Sco Op6a00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 8) == 0) // bpl: ~N
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6a01] bpl 3 ----------
static struct Sco Op6a01(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 8) == 0) // bpl: ~N
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6aff] bpl 33333335 ----------
static struct Sco Op6aff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 8) == 0) // bpl: ~N
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6b00] bmi 3335 ----------
static struct Sco Op6b00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ( o.sr & 8      ) // bmi:  N
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6b01] bmi 3 ----------
static struct Sco Op6b01(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ( o.sr & 8      ) // bmi:  N
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6bff] bmi 33333335 ----------
static struct Sco Op6bff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ( o.sr & 8      ) // bmi:  N
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6c00] bge 3335 ----------
static struct Sco Op6c00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // bge: ~N ~V or N  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6c01] bge 3 ----------
static struct Sco Op6c01(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // bge: ~N ~V or N  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6cff] bge 33333335 ----------
static struct Sco Op6cff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x0 || (o.sr & 0xa) == 0xa) // bge: ~N ~V or N  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6d00] blt 3335 ----------
static struct Sco Op6d00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // blt: ~N  V or N ~V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6d01] blt 3 ----------
static struct Sco Op6d01(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // blt: ~N  V or N ~V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6dff] blt 33333335 ----------
static struct Sco Op6dff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8) // blt: ~N  V or N ~V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6e00] bgt 3335 ----------
static struct Sco Op6e00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // bgt: ~N ~Z ~V or N ~Z  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6e01] bgt 3 ----------
static struct Sco Op6e01(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // bgt: ~N ~Z ~V or N ~Z  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6eff] bgt 33333335 ----------
static struct Sco Op6eff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xe) == 0x0 || (o.sr & 0xe) == 0xa) // bgt: ~N ~Z ~V or N ~Z  V
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6f00] ble 3335 ----------
static struct Sco Op6f00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$3333' into val:
	val = (s16)o.pc[1]; // Fetch immediate value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // ble: ~N  V or N ~V or Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 2;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6f01] ble 3 ----------
static struct Sco Op6f01(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	val = ((o.pc[0] + 0x80) & 0xff) - 0x80;

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // ble: ~N  V or N ~V or Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 1;
	}

	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [6fff] ble 33333335 ----------
static struct Sco Op6fff(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	// Get Branch offset:
	// EaRead : Read '#$33333333' into val:
	val = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Is the condition true? (XNZVC)
	if ((o.sr & 0xa) == 0x2 || (o.sr & 0xa) == 0x8 || (o.sr & 4)) // ble: ~N  V or N ~V or Z
	{
		// Take branch, add on val to PC:
		o.pc += 1 + (val >> 1);
		o.cycles -= 2;
	}
	else
	{
		// Don't branch, just increment PC normally:
		o.pc += 3;
	}

	o.pc = sc->checkpc(o.pc);
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [7000] moveq #$0, d0 ----------
static struct Sco Op7000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	val = o.pc[0]; // Get opcode
	off = (val & 0x0e00) >> 9; // Get target register
	val = ((val + 0x80) & 0xff) - 0x80; // Sign-extend

	sc->d[off] = val; // Store into Dn

	res = val;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8000] or.b d0, d0 ----------
static struct Sco Op8000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8010] or.b (a0), d0 ----------
static struct Sco Op8010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8018] or.b (a0)+, d0 ----------
static struct Sco Op8018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [801f] or.b (a7)+, d0 ----------
static struct Sco Op801f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8020] or.b -(a0), d0 ----------
static struct Sco Op8020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8027] or.b -(a7), d0 ----------
static struct Sco Op8027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8028] or.b ($3333,a0), d0 ----------
static struct Sco Op8028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8030] or.b ($33,a0,d3.w*2), d0 ----------
static struct Sco Op8030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8038] or.b $3333.w, d0 ----------
static struct Sco Op8038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8039] or.b $33333333.l, d0 ----------
static struct Sco Op8039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [803a] or.b ($3333,pc), d0; =3335 ----------
static struct Sco Op803a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [803b] or.b ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op803b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [803c] or.b #$33, d0 ----------
static struct Sco Op803c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8040] or.w d0, d0 ----------
static struct Sco Op8040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8050] or.w (a0), d0 ----------
static struct Sco Op8050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8058] or.w (a0)+, d0 ----------
static struct Sco Op8058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [805f] or.w (a7)+, d0 ----------
static struct Sco Op805f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8060] or.w -(a0), d0 ----------
static struct Sco Op8060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8067] or.w -(a7), d0 ----------
static struct Sco Op8067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8068] or.w ($3333,a0), d0 ----------
static struct Sco Op8068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8070] or.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Op8070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8078] or.w $3333.w, d0 ----------
static struct Sco Op8078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8079] or.w $33333333.l, d0 ----------
static struct Sco Op8079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [807a] or.w ($3333,pc), d0; =3335 ----------
static struct Sco Op807a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [807b] or.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op807b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [807c] or.w #$3333, d0 ----------
static struct Sco Op807c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8080] or.l d0, d0 ----------
static struct Sco Op8080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8090] or.l (a0), d0 ----------
static struct Sco Op8090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8098] or.l (a0)+, d0 ----------
static struct Sco Op8098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [809f] or.l (a7)+, d0 ----------
static struct Sco Op809f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80a0] or.l -(a0), d0 ----------
static struct Sco Op80a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80a7] or.l -(a7), d0 ----------
static struct Sco Op80a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80a8] or.l ($3333,a0), d0 ----------
static struct Sco Op80a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80b0] or.l ($33,a0,d3.w*2), d0 ----------
static struct Sco Op80b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80b8] or.l $3333.w, d0 ----------
static struct Sco Op80b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80b9] or.l $33333333.l, d0 ----------
static struct Sco Op80b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80ba] or.l ($3333,pc), d0; =3335 ----------
static struct Sco Op80ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80bb] or.l ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op80bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80bc] or.l #$33333333, d0 ----------
static struct Sco Op80bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80c0] divu.w d0, d0 ----------
static struct Sco Op80c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 133;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80d0] divu.w (a0), d0 ----------
static struct Sco Op80d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 137;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80d8] divu.w (a0)+, d0 ----------
static struct Sco Op80d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 137;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80df] divu.w (a7)+, d0 ----------
static struct Sco Op80df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 137;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80e0] divu.w -(a0), d0 ----------
static struct Sco Op80e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 139;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80e7] divu.w -(a7), d0 ----------
static struct Sco Op80e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 139;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80e8] divu.w ($3333,a0), d0 ----------
static struct Sco Op80e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 141;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80f0] divu.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Op80f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 143;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80f8] divu.w $3333.w, d0 ----------
static struct Sco Op80f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 141;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80f9] divu.w $33333333.l, d0 ----------
static struct Sco Op80f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 145;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80fa] divu.w ($3333,pc), d0; =3335 ----------
static struct Sco Op80fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 141;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80fb] divu.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op80fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 143;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [80fc] divu.w #$3333, d0 ----------
static struct Sco Op80fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaRead : Read '#$3333' into a:
	a = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)(b / a);
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = b % a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 133;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8110] or.b d0, (a0) ----------
static struct Sco Op8110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8118] or.b d0, (a0)+ ----------
static struct Sco Op8118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [811f] or.b d0, (a7)+ ----------
static struct Sco Op811f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8120] or.b d0, -(a0) ----------
static struct Sco Op8120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8127] or.b d0, -(a7) ----------
static struct Sco Op8127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8128] or.b d0, ($3333,a0) ----------
static struct Sco Op8128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8130] or.b d0, ($33,a0,d3.w*2) ----------
static struct Sco Op8130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8138] or.b d0, $3333.w ----------
static struct Sco Op8138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8139] or.b d0, $33333333.l ----------
static struct Sco Op8139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [813a] or.b d0, ($3333,pc); =3335 ----------
static struct Sco Op813a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [813b] or.b d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op813b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8150] or.w d0, (a0) ----------
static struct Sco Op8150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8158] or.w d0, (a0)+ ----------
static struct Sco Op8158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [815f] or.w d0, (a7)+ ----------
static struct Sco Op815f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8160] or.w d0, -(a0) ----------
static struct Sco Op8160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8167] or.w d0, -(a7) ----------
static struct Sco Op8167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8168] or.w d0, ($3333,a0) ----------
static struct Sco Op8168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8170] or.w d0, ($33,a0,d3.w*2) ----------
static struct Sco Op8170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8178] or.w d0, $3333.w ----------
static struct Sco Op8178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8179] or.w d0, $33333333.l ----------
static struct Sco Op8179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [817a] or.w d0, ($3333,pc); =3335 ----------
static struct Sco Op817a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [817b] or.w d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op817b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a | b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8190] or.l d0, (a0) ----------
static struct Sco Op8190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [8198] or.l d0, (a0)+ ----------
static struct Sco Op8198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [819f] or.l d0, (a7)+ ----------
static struct Sco Op819f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81a0] or.l d0, -(a0) ----------
static struct Sco Op81a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81a7] or.l d0, -(a7) ----------
static struct Sco Op81a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81a8] or.l d0, ($3333,a0) ----------
static struct Sco Op81a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81b0] or.l d0, ($33,a0,d3.w*2) ----------
static struct Sco Op81b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81b8] or.l d0, $3333.w ----------
static struct Sco Op81b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81b9] or.l d0, $33333333.l ----------
static struct Sco Op81b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81ba] or.l d0, ($3333,pc); =3335 ----------
static struct Sco Op81ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81bb] or.l d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op81bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a | b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81c0] divs.w d0, d0 ----------
static struct Sco Op81c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 133;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81d0] divs.w (a0), d0 ----------
static struct Sco Op81d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 137;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81d8] divs.w (a0)+, d0 ----------
static struct Sco Op81d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 137;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81df] divs.w (a7)+, d0 ----------
static struct Sco Op81df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 137;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81e0] divs.w -(a0), d0 ----------
static struct Sco Op81e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 139;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81e7] divs.w -(a7), d0 ----------
static struct Sco Op81e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 139;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81e8] divs.w ($3333,a0), d0 ----------
static struct Sco Op81e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 141;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81f0] divs.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Op81f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 143;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81f8] divs.w $3333.w, d0 ----------
static struct Sco Op81f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 141;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81f9] divs.w $33333333.l, d0 ----------
static struct Sco Op81f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 145;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81fa] divs.w ($3333,pc), d0; =3335 ----------
static struct Sco Op81fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 141;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81fb] divs.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op81fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 143;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [81fc] divs.w #$3333, d0 ----------
static struct Sco Op81fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;
	u32 rm = 0;

	// EaRead : Read '#$3333' into a:
	a = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (u16)( (s32)b / (s16)a );
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	rm = (s32)b % (s16)a; // Get remainder
	res |= ((u16)rm) << 16;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 133;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9000] sub.b d0, d0 ----------
static struct Sco Op9000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9010] sub.b (a0), d0 ----------
static struct Sco Op9010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9018] sub.b (a0)+, d0 ----------
static struct Sco Op9018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [901f] sub.b (a7)+, d0 ----------
static struct Sco Op901f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9020] sub.b -(a0), d0 ----------
static struct Sco Op9020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9027] sub.b -(a7), d0 ----------
static struct Sco Op9027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9028] sub.b ($3333,a0), d0 ----------
static struct Sco Op9028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9030] sub.b ($33,a0,d3.w*2), d0 ----------
static struct Sco Op9030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9038] sub.b $3333.w, d0 ----------
static struct Sco Op9038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9039] sub.b $33333333.l, d0 ----------
static struct Sco Op9039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [903a] sub.b ($3333,pc), d0; =3335 ----------
static struct Sco Op903a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [903b] sub.b ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op903b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [903c] sub.b #$33, d0 ----------
static struct Sco Op903c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9040] sub.w d0, d0 ----------
static struct Sco Op9040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9050] sub.w (a0), d0 ----------
static struct Sco Op9050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9058] sub.w (a0)+, d0 ----------
static struct Sco Op9058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [905f] sub.w (a7)+, d0 ----------
static struct Sco Op905f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9060] sub.w -(a0), d0 ----------
static struct Sco Op9060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9067] sub.w -(a7), d0 ----------
static struct Sco Op9067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9068] sub.w ($3333,a0), d0 ----------
static struct Sco Op9068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9070] sub.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Op9070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9078] sub.w $3333.w, d0 ----------
static struct Sco Op9078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9079] sub.w $33333333.l, d0 ----------
static struct Sco Op9079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [907a] sub.w ($3333,pc), d0; =3335 ----------
static struct Sco Op907a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [907b] sub.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op907b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [907c] sub.w #$3333, d0 ----------
static struct Sco Op907c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9080] sub.l d0, d0 ----------
static struct Sco Op9080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9090] sub.l (a0), d0 ----------
static struct Sco Op9090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9098] sub.l (a0)+, d0 ----------
static struct Sco Op9098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [909f] sub.l (a7)+, d0 ----------
static struct Sco Op909f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90a0] sub.l -(a0), d0 ----------
static struct Sco Op90a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90a7] sub.l -(a7), d0 ----------
static struct Sco Op90a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90a8] sub.l ($3333,a0), d0 ----------
static struct Sco Op90a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90b0] sub.l ($33,a0,d3.w*2), d0 ----------
static struct Sco Op90b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90b8] sub.l $3333.w, d0 ----------
static struct Sco Op90b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90b9] sub.l $33333333.l, d0 ----------
static struct Sco Op90b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90ba] sub.l ($3333,pc), d0; =3335 ----------
static struct Sco Op90ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90bb] sub.l ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Op90bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90bc] sub.l #$33333333, d0 ----------
static struct Sco Op90bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90c0] suba.w d0, a0 ----------
static struct Sco Op90c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90d0] suba.w (a0), a0 ----------
static struct Sco Op90d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90d8] suba.w (a0)+, a0 ----------
static struct Sco Op90d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90df] suba.w (a7)+, a0 ----------
static struct Sco Op90df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90e0] suba.w -(a0), a0 ----------
static struct Sco Op90e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90e7] suba.w -(a7), a0 ----------
static struct Sco Op90e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90e8] suba.w ($3333,a0), a0 ----------
static struct Sco Op90e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90f0] suba.w ($33,a0,d3.w*2), a0 ----------
static struct Sco Op90f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90f8] suba.w $3333.w, a0 ----------
static struct Sco Op90f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90f9] suba.w $33333333.l, a0 ----------
static struct Sco Op90f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90fa] suba.w ($3333,pc), a0; =3335 ----------
static struct Sco Op90fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90fb] suba.w ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Op90fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [90fc] suba.w #$3333, a0 ----------
static struct Sco Op90fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9100] subx.b d0, d0 ----------
static struct Sco Op9100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0, carry = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	carry = (o.sr >> 4) & 1; 
	res = a - b + 1 - carry;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write a into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= a & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9110] sub.b d0, (a0) ----------
static struct Sco Op9110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9118] sub.b d0, (a0)+ ----------
static struct Sco Op9118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [911f] sub.b d0, (a7)+ ----------
static struct Sco Op911f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9120] sub.b d0, -(a0) ----------
static struct Sco Op9120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9127] sub.b d0, -(a7) ----------
static struct Sco Op9127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9128] sub.b d0, ($3333,a0) ----------
static struct Sco Op9128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9130] sub.b d0, ($33,a0,d3.w*2) ----------
static struct Sco Op9130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9138] sub.b d0, $3333.w ----------
static struct Sco Op9138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9139] sub.b d0, $33333333.l ----------
static struct Sco Op9139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [913a] sub.b d0, ($3333,pc); =3335 ----------
static struct Sco Op913a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [913b] sub.b d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op913b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9140] subx.w d0, d0 ----------
static struct Sco Op9140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0, carry = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	carry = (o.sr >> 4) & 1; 
	res = a - b + 1 - carry;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write a into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= a & 0xffff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9150] sub.w d0, (a0) ----------
static struct Sco Op9150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9158] sub.w d0, (a0)+ ----------
static struct Sco Op9158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [915f] sub.w d0, (a7)+ ----------
static struct Sco Op915f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9160] sub.w d0, -(a0) ----------
static struct Sco Op9160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9167] sub.w d0, -(a7) ----------
static struct Sco Op9167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9168] sub.w d0, ($3333,a0) ----------
static struct Sco Op9168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9170] sub.w d0, ($33,a0,d3.w*2) ----------
static struct Sco Op9170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9178] sub.w d0, $3333.w ----------
static struct Sco Op9178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9179] sub.w d0, $33333333.l ----------
static struct Sco Op9179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [917a] sub.w d0, ($3333,pc); =3335 ----------
static struct Sco Op917a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [917b] sub.w d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op917b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9180] subx.l d0, d0 ----------
static struct Sco Op9180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0, carry = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	carry = (o.sr >> 4) & 1; 
	res = a - b + 1 - carry;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write a into register[off]:
	sc->d[off] = a;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9190] sub.l d0, (a0) ----------
static struct Sco Op9190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [9198] sub.l d0, (a0)+ ----------
static struct Sco Op9198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [919f] sub.l d0, (a7)+ ----------
static struct Sco Op919f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91a0] sub.l d0, -(a0) ----------
static struct Sco Op91a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91a7] sub.l d0, -(a7) ----------
static struct Sco Op91a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91a8] sub.l d0, ($3333,a0) ----------
static struct Sco Op91a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91b0] sub.l d0, ($33,a0,d3.w*2) ----------
static struct Sco Op91b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91b8] sub.l d0, $3333.w ----------
static struct Sco Op91b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91b9] sub.l d0, $33333333.l ----------
static struct Sco Op91b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91ba] sub.l d0, ($3333,pc); =3335 ----------
static struct Sco Op91ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91bb] sub.l d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Op91bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91c0] suba.l d0, a0 ----------
static struct Sco Op91c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91d0] suba.l (a0), a0 ----------
static struct Sco Op91d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91d8] suba.l (a0)+, a0 ----------
static struct Sco Op91d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91df] suba.l (a7)+, a0 ----------
static struct Sco Op91df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91e0] suba.l -(a0), a0 ----------
static struct Sco Op91e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91e7] suba.l -(a7), a0 ----------
static struct Sco Op91e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91e8] suba.l ($3333,a0), a0 ----------
static struct Sco Op91e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91f0] suba.l ($33,a0,d3.w*2), a0 ----------
static struct Sco Op91f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91f8] suba.l $3333.w, a0 ----------
static struct Sco Op91f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91f9] suba.l $33333333.l, a0 ----------
static struct Sco Op91f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91fa] suba.l ($3333,pc), a0; =3335 ----------
static struct Sco Op91fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91fb] suba.l ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Op91fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [91fc] suba.l #$33333333, a0 ----------
static struct Sco Op91fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b000] cmp.b d0, d0 ----------
static struct Sco Opb000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b010] cmp.b (a0), d0 ----------
static struct Sco Opb010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b018] cmp.b (a0)+, d0 ----------
static struct Sco Opb018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b01f] cmp.b (a7)+, d0 ----------
static struct Sco Opb01f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b020] cmp.b -(a0), d0 ----------
static struct Sco Opb020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b027] cmp.b -(a7), d0 ----------
static struct Sco Opb027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b028] cmp.b ($3333,a0), d0 ----------
static struct Sco Opb028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b030] cmp.b ($33,a0,d3.w*2), d0 ----------
static struct Sco Opb030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b038] cmp.b $3333.w, d0 ----------
static struct Sco Opb038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b039] cmp.b $33333333.l, d0 ----------
static struct Sco Opb039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b03a] cmp.b ($3333,pc), d0; =3335 ----------
static struct Sco Opb03a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b03b] cmp.b ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opb03b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b03c] cmp.b #$33, d0 ----------
static struct Sco Opb03c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// Do arithmetic:
	res = a - b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res > (u8)a) o.sr |= 1; // C

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b040] cmp.w d0, d0 ----------
static struct Sco Opb040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b050] cmp.w (a0), d0 ----------
static struct Sco Opb050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b058] cmp.w (a0)+, d0 ----------
static struct Sco Opb058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b05f] cmp.w (a7)+, d0 ----------
static struct Sco Opb05f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b060] cmp.w -(a0), d0 ----------
static struct Sco Opb060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b067] cmp.w -(a7), d0 ----------
static struct Sco Opb067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b068] cmp.w ($3333,a0), d0 ----------
static struct Sco Opb068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b070] cmp.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Opb070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b078] cmp.w $3333.w, d0 ----------
static struct Sco Opb078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b079] cmp.w $33333333.l, d0 ----------
static struct Sco Opb079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b07a] cmp.w ($3333,pc), d0; =3335 ----------
static struct Sco Opb07a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b07b] cmp.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opb07b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b07c] cmp.w #$3333, d0 ----------
static struct Sco Opb07c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// Do arithmetic:
	res = a - b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res > (u16)a) o.sr |= 1; // C

	o.pc += 2;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b080] cmp.l d0, d0 ----------
static struct Sco Opb080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b090] cmp.l (a0), d0 ----------
static struct Sco Opb090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b098] cmp.l (a0)+, d0 ----------
static struct Sco Opb098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b09f] cmp.l (a7)+, d0 ----------
static struct Sco Opb09f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0a0] cmp.l -(a0), d0 ----------
static struct Sco Opb0a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0a7] cmp.l -(a7), d0 ----------
static struct Sco Opb0a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0a8] cmp.l ($3333,a0), d0 ----------
static struct Sco Opb0a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0b0] cmp.l ($33,a0,d3.w*2), d0 ----------
static struct Sco Opb0b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0b8] cmp.l $3333.w, d0 ----------
static struct Sco Opb0b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0b9] cmp.l $33333333.l, d0 ----------
static struct Sco Opb0b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0ba] cmp.l ($3333,pc), d0; =3335 ----------
static struct Sco Opb0ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0bb] cmp.l ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opb0bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0bc] cmp.l #$33333333, d0 ----------
static struct Sco Opb0bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Do arithmetic:
	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0c0] cmpa.w d0, a0 ----------
static struct Sco Opb0c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0d0] cmpa.w (a0), a0 ----------
static struct Sco Opb0d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0d8] cmpa.w (a0)+, a0 ----------
static struct Sco Opb0d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0df] cmpa.w (a7)+, a0 ----------
static struct Sco Opb0df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0e0] cmpa.w -(a0), a0 ----------
static struct Sco Opb0e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0e7] cmpa.w -(a7), a0 ----------
static struct Sco Opb0e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0e8] cmpa.w ($3333,a0), a0 ----------
static struct Sco Opb0e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0f0] cmpa.w ($33,a0,d3.w*2), a0 ----------
static struct Sco Opb0f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0f8] cmpa.w $3333.w, a0 ----------
static struct Sco Opb0f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0f9] cmpa.w $33333333.l, a0 ----------
static struct Sco Opb0f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0fa] cmpa.w ($3333,pc), a0; =3335 ----------
static struct Sco Opb0fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0fb] cmpa.w ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Opb0fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b0fc] cmpa.w #$3333, a0 ----------
static struct Sco Opb0fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b100] eor.b d0, d0 ----------
static struct Sco Opb100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b110] eor.b d0, (a0) ----------
static struct Sco Opb110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b118] eor.b d0, (a0)+ ----------
static struct Sco Opb118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b11f] eor.b d0, (a7)+ ----------
static struct Sco Opb11f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b120] eor.b d0, -(a0) ----------
static struct Sco Opb120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b127] eor.b d0, -(a7) ----------
static struct Sco Opb127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b128] eor.b d0, ($3333,a0) ----------
static struct Sco Opb128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b130] eor.b d0, ($33,a0,d3.w*2) ----------
static struct Sco Opb130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b138] eor.b d0, $3333.w ----------
static struct Sco Opb138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b139] eor.b d0, $33333333.l ----------
static struct Sco Opb139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s8)sc->read8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b13a] eor.b d0, ($3333,pc); =3335 ----------
static struct Sco Opb13a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b13b] eor.b d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opb13b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s8)sc->fetch8(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b140] eor.w d0, d0 ----------
static struct Sco Opb140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b150] eor.w d0, (a0) ----------
static struct Sco Opb150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b158] eor.w d0, (a0)+ ----------
static struct Sco Opb158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b15f] eor.w d0, (a7)+ ----------
static struct Sco Opb15f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b160] eor.w d0, -(a0) ----------
static struct Sco Opb160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b167] eor.w d0, -(a7) ----------
static struct Sco Opb167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b168] eor.w d0, ($3333,a0) ----------
static struct Sco Opb168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b170] eor.w d0, ($33,a0,d3.w*2) ----------
static struct Sco Opb170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b178] eor.w d0, $3333.w ----------
static struct Sco Opb178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b179] eor.w d0, $33333333.l ----------
static struct Sco Opb179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b17a] eor.w d0, ($3333,pc); =3335 ----------
static struct Sco Opb17a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b17b] eor.w d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opb17b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// Do arithmetic:
	res = a ^ b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b180] eor.l d0, d0 ----------
static struct Sco Opb180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b190] eor.l d0, (a0) ----------
static struct Sco Opb190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b198] eor.l d0, (a0)+ ----------
static struct Sco Opb198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b19f] eor.l d0, (a7)+ ----------
static struct Sco Opb19f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1a0] eor.l d0, -(a0) ----------
static struct Sco Opb1a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1a7] eor.l d0, -(a7) ----------
static struct Sco Opb1a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1a8] eor.l d0, ($3333,a0) ----------
static struct Sco Opb1a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1b0] eor.l d0, ($33,a0,d3.w*2) ----------
static struct Sco Opb1b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1b8] eor.l d0, $3333.w ----------
static struct Sco Opb1b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1b9] eor.l d0, $33333333.l ----------
static struct Sco Opb1b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 28;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1ba] eor.l d0, ($3333,pc); =3335 ----------
static struct Sco Opb1ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1bb] eor.l d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opb1bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// Get register operand into a:
	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Get EA into off and value into b:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// Do arithmetic:
	res = a ^ b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 26;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1c0] cmpa.l d0, a0 ----------
static struct Sco Opb1c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1d0] cmpa.l (a0), a0 ----------
static struct Sco Opb1d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1d8] cmpa.l (a0)+, a0 ----------
static struct Sco Opb1d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1df] cmpa.l (a7)+, a0 ----------
static struct Sco Opb1df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1e0] cmpa.l -(a0), a0 ----------
static struct Sco Opb1e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1e7] cmpa.l -(a7), a0 ----------
static struct Sco Opb1e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1e8] cmpa.l ($3333,a0), a0 ----------
static struct Sco Opb1e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1f0] cmpa.l ($33,a0,d3.w*2), a0 ----------
static struct Sco Opb1f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1f8] cmpa.l $3333.w, a0 ----------
static struct Sco Opb1f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1f9] cmpa.l $33333333.l, a0 ----------
static struct Sco Opb1f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1fa] cmpa.l ($3333,pc), a0; =3335 ----------
static struct Sco Opb1fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1fb] cmpa.l ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Opb1fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [b1fc] cmpa.l #$33333333, a0 ----------
static struct Sco Opb1fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a - b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ b) & (a ^ res) & 0x80000000) o.sr |= 2; // V
	if (res > a) o.sr |= 1; // C

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c000] and.b d0, d0 ----------
static struct Sco Opc000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c010] and.b (a0), d0 ----------
static struct Sco Opc010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c018] and.b (a0)+, d0 ----------
static struct Sco Opc018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c01f] and.b (a7)+, d0 ----------
static struct Sco Opc01f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c020] and.b -(a0), d0 ----------
static struct Sco Opc020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c027] and.b -(a7), d0 ----------
static struct Sco Opc027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c028] and.b ($3333,a0), d0 ----------
static struct Sco Opc028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c030] and.b ($33,a0,d3.w*2), d0 ----------
static struct Sco Opc030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c038] and.b $3333.w, d0 ----------
static struct Sco Opc038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c039] and.b $33333333.l, d0 ----------
static struct Sco Opc039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c03a] and.b ($3333,pc), d0; =3335 ----------
static struct Sco Opc03a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c03b] and.b ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opc03b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c03c] and.b #$33, d0 ----------
static struct Sco Opc03c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c040] and.w d0, d0 ----------
static struct Sco Opc040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c050] and.w (a0), d0 ----------
static struct Sco Opc050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c058] and.w (a0)+, d0 ----------
static struct Sco Opc058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c05f] and.w (a7)+, d0 ----------
static struct Sco Opc05f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c060] and.w -(a0), d0 ----------
static struct Sco Opc060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c067] and.w -(a7), d0 ----------
static struct Sco Opc067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c068] and.w ($3333,a0), d0 ----------
static struct Sco Opc068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c070] and.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Opc070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c078] and.w $3333.w, d0 ----------
static struct Sco Opc078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c079] and.w $33333333.l, d0 ----------
static struct Sco Opc079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c07a] and.w ($3333,pc), d0; =3335 ----------
static struct Sco Opc07a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c07b] and.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opc07b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c07c] and.w #$3333, d0 ----------
static struct Sco Opc07c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c080] and.l d0, d0 ----------
static struct Sco Opc080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c090] and.l (a0), d0 ----------
static struct Sco Opc090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c098] and.l (a0)+, d0 ----------
static struct Sco Opc098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c09f] and.l (a7)+, d0 ----------
static struct Sco Opc09f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0a0] and.l -(a0), d0 ----------
static struct Sco Opc0a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0a7] and.l -(a7), d0 ----------
static struct Sco Opc0a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0a8] and.l ($3333,a0), d0 ----------
static struct Sco Opc0a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0b0] and.l ($33,a0,d3.w*2), d0 ----------
static struct Sco Opc0b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0b8] and.l $3333.w, d0 ----------
static struct Sco Opc0b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0b9] and.l $33333333.l, d0 ----------
static struct Sco Opc0b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0ba] and.l ($3333,pc), d0; =3335 ----------
static struct Sco Opc0ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0bb] and.l ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opc0bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0bc] and.l #$33333333, d0 ----------
static struct Sco Opc0bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0c0] mulu.w d0, d0 ----------
static struct Sco Opc0c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 70;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0d0] mulu.w (a0), d0 ----------
static struct Sco Opc0d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 74;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0d8] mulu.w (a0)+, d0 ----------
static struct Sco Opc0d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 74;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0df] mulu.w (a7)+, d0 ----------
static struct Sco Opc0df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 74;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0e0] mulu.w -(a0), d0 ----------
static struct Sco Opc0e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 76;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0e7] mulu.w -(a7), d0 ----------
static struct Sco Opc0e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 76;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0e8] mulu.w ($3333,a0), d0 ----------
static struct Sco Opc0e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 78;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0f0] mulu.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Opc0f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 80;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0f8] mulu.w $3333.w, d0 ----------
static struct Sco Opc0f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 78;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0f9] mulu.w $33333333.l, d0 ----------
static struct Sco Opc0f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 82;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0fa] mulu.w ($3333,pc), d0; =3335 ----------
static struct Sco Opc0fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 78;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0fb] mulu.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opc0fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 80;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c0fc] mulu.w #$3333, d0 ----------
static struct Sco Opc0fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into a:
	a = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = a * b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 70;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c110] and.b d0, (a0) ----------
static struct Sco Opc110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c118] and.b d0, (a0)+ ----------
static struct Sco Opc118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c11f] and.b d0, (a7)+ ----------
static struct Sco Opc11f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c120] and.b d0, -(a0) ----------
static struct Sco Opc120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c127] and.b d0, -(a7) ----------
static struct Sco Opc127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c128] and.b d0, ($3333,a0) ----------
static struct Sco Opc128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c130] and.b d0, ($33,a0,d3.w*2) ----------
static struct Sco Opc130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c138] and.b d0, $3333.w ----------
static struct Sco Opc138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c139] and.b d0, $33333333.l ----------
static struct Sco Opc139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c13a] and.b d0, ($3333,pc); =3335 ----------
static struct Sco Opc13a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c13b] and.b d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opc13b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c150] and.w d0, (a0) ----------
static struct Sco Opc150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c158] and.w d0, (a0)+ ----------
static struct Sco Opc158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c15f] and.w d0, (a7)+ ----------
static struct Sco Opc15f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c160] and.w d0, -(a0) ----------
static struct Sco Opc160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c167] and.w d0, -(a7) ----------
static struct Sco Opc167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c168] and.w d0, ($3333,a0) ----------
static struct Sco Opc168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c170] and.w d0, ($33,a0,d3.w*2) ----------
static struct Sco Opc170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c178] and.w d0, $3333.w ----------
static struct Sco Opc178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c179] and.w d0, $33333333.l ----------
static struct Sco Opc179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c17a] and.w d0, ($3333,pc); =3335 ----------
static struct Sco Opc17a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c17b] and.w d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opc17b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a & b;
	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c190] and.l d0, (a0) ----------
static struct Sco Opc190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c198] and.l d0, (a0)+ ----------
static struct Sco Opc198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c19f] and.l d0, (a7)+ ----------
static struct Sco Opc19f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1a0] and.l d0, -(a0) ----------
static struct Sco Opc1a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1a7] and.l d0, -(a7) ----------
static struct Sco Opc1a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1a8] and.l d0, ($3333,a0) ----------
static struct Sco Opc1a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1b0] and.l d0, ($33,a0,d3.w*2) ----------
static struct Sco Opc1b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1b8] and.l d0, $3333.w ----------
static struct Sco Opc1b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1b9] and.l d0, $33333333.l ----------
static struct Sco Opc1b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1ba] and.l d0, ($3333,pc); =3335 ----------
static struct Sco Opc1ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1bb] and.l d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opc1bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a & b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1c0] muls.w d0, d0 ----------
static struct Sco Opc1c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 70;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1d0] muls.w (a0), d0 ----------
static struct Sco Opc1d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 74;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1d8] muls.w (a0)+, d0 ----------
static struct Sco Opc1d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 74;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1df] muls.w (a7)+, d0 ----------
static struct Sco Opc1df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 74;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1e0] muls.w -(a0), d0 ----------
static struct Sco Opc1e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 76;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1e7] muls.w -(a7), d0 ----------
static struct Sco Opc1e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 76;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1e8] muls.w ($3333,a0), d0 ----------
static struct Sco Opc1e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 78;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1f0] muls.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Opc1f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 80;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1f8] muls.w $3333.w, d0 ----------
static struct Sco Opc1f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 78;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1f9] muls.w $33333333.l, d0 ----------
static struct Sco Opc1f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 82;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1fa] muls.w ($3333,pc), d0; =3335 ----------
static struct Sco Opc1fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 78;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1fb] muls.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opc1fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 80;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [c1fc] muls.w #$3333, d0 ----------
static struct Sco Opc1fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into a:
	a = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	res = (s16)a * (s32)b;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 70;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d000] add.b d0, d0 ----------
static struct Sco Opd000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d010] add.b (a0), d0 ----------
static struct Sco Opd010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d018] add.b (a0)+, d0 ----------
static struct Sco Opd018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d01f] add.b (a7)+, d0 ----------
static struct Sco Opd01f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d020] add.b -(a0), d0 ----------
static struct Sco Opd020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d027] add.b -(a7), d0 ----------
static struct Sco Opd027(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d028] add.b ($3333,a0), d0 ----------
static struct Sco Opd028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d030] add.b ($33,a0,d3.w*2), d0 ----------
static struct Sco Opd030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d038] add.b $3333.w, d0 ----------
static struct Sco Opd038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d039] add.b $33333333.l, d0 ----------
static struct Sco Opd039(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d03a] add.b ($3333,pc), d0; =3335 ----------
static struct Sco Opd03a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d03b] add.b ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opd03b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d03c] add.b #$33, d0 ----------
static struct Sco Opd03c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33' into b:
	b = (s8)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xff;
	sc->d[roff] |= res & 0xff;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d040] add.w d0, d0 ----------
static struct Sco Opd040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d050] add.w (a0), d0 ----------
static struct Sco Opd050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d058] add.w (a0)+, d0 ----------
static struct Sco Opd058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d05f] add.w (a7)+, d0 ----------
static struct Sco Opd05f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d060] add.w -(a0), d0 ----------
static struct Sco Opd060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d067] add.w -(a7), d0 ----------
static struct Sco Opd067(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d068] add.w ($3333,a0), d0 ----------
static struct Sco Opd068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d070] add.w ($33,a0,d3.w*2), d0 ----------
static struct Sco Opd070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d078] add.w $3333.w, d0 ----------
static struct Sco Opd078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d079] add.w $33333333.l, d0 ----------
static struct Sco Opd079(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d07a] add.w ($3333,pc), d0; =3335 ----------
static struct Sco Opd07a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d07b] add.w ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opd07b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d07c] add.w #$3333, d0 ----------
static struct Sco Opd07c(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] &= ~0xffff;
	sc->d[roff] |= res & 0xffff;

	o.pc += 2;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d080] add.l d0, d0 ----------
static struct Sco Opd080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d090] add.l (a0), d0 ----------
static struct Sco Opd090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d098] add.l (a0)+, d0 ----------
static struct Sco Opd098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d09f] add.l (a7)+, d0 ----------
static struct Sco Opd09f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0a0] add.l -(a0), d0 ----------
static struct Sco Opd0a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0a7] add.l -(a7), d0 ----------
static struct Sco Opd0a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0a8] add.l ($3333,a0), d0 ----------
static struct Sco Opd0a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0b0] add.l ($33,a0,d3.w*2), d0 ----------
static struct Sco Opd0b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0b8] add.l $3333.w, d0 ----------
static struct Sco Opd0b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0b9] add.l $33333333.l, d0 ----------
static struct Sco Opd0b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0ba] add.l ($3333,pc), d0; =3335 ----------
static struct Sco Opd0ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0bb] add.l ($33,pc,d3.w*2), d0; =35 ----------
static struct Sco Opd0bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0bc] add.l #$33333333, d0 ----------
static struct Sco Opd0bc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into a:
	a = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write res into register[roff]:
	sc->d[roff] = res;

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0c0] adda.w d0, a0 ----------
static struct Sco Opd0c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0d0] adda.w (a0), a0 ----------
static struct Sco Opd0d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0d8] adda.w (a0)+, a0 ----------
static struct Sco Opd0d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0df] adda.w (a7)+, a0 ----------
static struct Sco Opd0df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0e0] adda.w -(a0), a0 ----------
static struct Sco Opd0e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0e7] adda.w -(a7), a0 ----------
static struct Sco Opd0e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0e8] adda.w ($3333,a0), a0 ----------
static struct Sco Opd0e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0f0] adda.w ($33,a0,d3.w*2), a0 ----------
static struct Sco Opd0f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0f8] adda.w $3333.w, a0 ----------
static struct Sco Opd0f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0f9] adda.w $33333333.l, a0 ----------
static struct Sco Opd0f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = (s16)sc->read16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0fa] adda.w ($3333,pc), a0; =3335 ----------
static struct Sco Opd0fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0fb] adda.w ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Opd0fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = (s16)sc->fetch16(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d0fc] adda.w #$3333, a0 ----------
static struct Sco Opd0fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$3333' into b:
	b = (s16)o.pc[1]; // Fetch immediate value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 4;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d100] addx.b d0, d0 ----------
static struct Sco Opd100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0, carry = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s8)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s8)sc->d[off];

	// Do arithmetic:
	carry = (o.sr >> 4) & 1; 
	res = a + b + carry;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write a into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= a & 0xff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d110] add.b d0, (a0) ----------
static struct Sco Opd110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d118] add.b d0, (a0)+ ----------
static struct Sco Opd118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 1; // Post-increment An
	off = sc->d[off] - 1;
	// EaRead : Read '(a0)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d11f] add.b d0, (a7)+ ----------
static struct Sco Opd11f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d120] add.b d0, -(a0) ----------
static struct Sco Opd120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 1; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d127] add.b d0, -(a7) ----------
static struct Sco Opd127(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d128] add.b d0, ($3333,a0) ----------
static struct Sco Opd128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d130] add.b d0, ($33,a0,d3.w*2) ----------
static struct Sco Opd130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d138] add.b d0, $3333.w ----------
static struct Sco Opd138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d139] add.b d0, $33333333.l ----------
static struct Sco Opd139(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s8)sc->read8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 3;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d13a] add.b d0, ($3333,pc); =3335 ----------
static struct Sco Opd13a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d13b] add.b d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opd13b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s8)sc->fetch8(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s8)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80) o.sr |= 2; // V
	if ((u8)res < (u8)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write8(off, (u8)res);

	o.pc += 2;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d140] addx.w d0, d0 ----------
static struct Sco Opd140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0, carry = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = (s16)sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = (s16)sc->d[off];

	// Do arithmetic:
	carry = (o.sr >> 4) & 1; 
	res = a + b + carry;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write a into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= a & 0xffff;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d150] add.w d0, (a0) ----------
static struct Sco Opd150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d158] add.w d0, (a0)+ ----------
static struct Sco Opd158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a0)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d15f] add.w d0, (a7)+ ----------
static struct Sco Opd15f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 2; // Post-increment An
	off = sc->d[off] - 2;
	// EaRead : Read '(a7)+' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 12;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d160] add.w d0, -(a0) ----------
static struct Sco Opd160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d167] add.w d0, -(a7) ----------
static struct Sco Opd167(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 2; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d168] add.w d0, ($3333,a0) ----------
static struct Sco Opd168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d170] add.w d0, ($33,a0,d3.w*2) ----------
static struct Sco Opd170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d178] add.w d0, $3333.w ----------
static struct Sco Opd178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d179] add.w d0, $33333333.l ----------
static struct Sco Opd179(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = (s16)sc->read16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 3;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d17a] add.w d0, ($3333,pc); =3335 ----------
static struct Sco Opd17a(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d17b] add.w d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opd17b(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = (s16)sc->fetch16(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = (s16)sc->d[roff];

	// Do arithmetic:
	res = a + b;
	res &= 0xffff;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x8000) o.sr |= 2; // V
	if ((u16)res < (u16)a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write16(off, (u16)res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d180] addx.l d0, d0 ----------
static struct Sco Opd180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0, carry = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	// Do arithmetic:
	carry = (o.sr >> 4) & 1; 
	res = a + b + carry;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite : Write a into register[off]:
	sc->d[off] = a;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d190] add.l d0, (a0) ----------
static struct Sco Opd190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d198] add.l d0, (a0)+ ----------
static struct Sco Opd198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a0)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d19f] add.l d0, (a7)+ ----------
static struct Sco Opd19f(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '(a7)+' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1a0] add.l d0, -(a0) ----------
static struct Sco Opd1a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a0)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1a7] add.l d0, -(a7) ----------
static struct Sco Opd1a7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '-(a7)' (address in off):
	sc->write32(off, res);

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1a8] add.l d0, ($3333,a0) ----------
static struct Sco Opd1a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,a0)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1b0] add.l d0, ($33,a0,d3.w*2) ----------
static struct Sco Opd1b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,a0,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1b8] add.l d0, $3333.w ----------
static struct Sco Opd1b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$3333.w' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1b9] add.l d0, $33333333.l ----------
static struct Sco Opd1b9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into a:
	a = sc->read32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '$33333333.l' (address in off):
	sc->write32(off, res);

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1ba] add.l d0, ($3333,pc); =3335 ----------
static struct Sco Opd1ba(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($3333,pc)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1bb] add.l d0, ($33,pc,d3.w*2); =35 ----------
static struct Sco Opd1bb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, roff = 0, b = 0;

	// Get off = EA val = EA value:
	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into a:
	a = sc->fetch32(off);

	// Get roff = Register rval = Register value:
	// EaCalc : Get register index into 'roff':
	roff = (o.pc[0] & 0x0e00) >> 9;
	// EaRead : Read register[roff] into b:
	b = sc->d[roff];

	// Do arithmetic:
	res = a + b;
	o.sr &= ~0x1f; // Clear XNZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((a ^ res) & (b ^ res) & 0x80000000) o.sr |= 2; // V
	if (res < a) o.sr |= 0x11; // X + C

	// Save result:
	// EaWrite: Write res into '($33,pc,d3.w*2)' (address in off):
	sc->write32(off, res);

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1c0] adda.l d0, a0 ----------
static struct Sco Opd1c0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x000f;
	// EaRead : Read register[off] into b:
	b = sc->d[off];

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1d0] adda.l (a0), a0 ----------
static struct Sco Opd1d0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	off = sc->d[off];
	// EaRead : Read '(a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1d8] adda.l (a0)+, a0 ----------
static struct Sco Opd1d8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a0)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a0)+' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1df] adda.l (a7)+, a0 ----------
static struct Sco Opd1df(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '(a7)+':
	off = o.pc[0] & 0x000f;
	sc->d[off] += 4; // Post-increment An
	off = sc->d[off] - 4;
	// EaRead : Read '(a7)+' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 14;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1e0] adda.l -(a0), a0 ----------
static struct Sco Opd1e0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a0)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1e7] adda.l -(a7), a0 ----------
static struct Sco Opd1e7(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '-(a7)':
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
	sc->d[off] -= 4; // Pre-decrement An
	off = sc->d[off];
	// EaRead : Read '-(a7)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 1;
	o.cycles -= 16;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1e8] adda.l ($3333,a0), a0 ----------
static struct Sco Opd1e8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,a0)':
	off = o.pc[0] & 0x000f;
	off = sc->d[off] + (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,a0)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1f0] adda.l ($33,a0,d3.w*2), a0 ----------
static struct Sco Opd1f0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,a0,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		s32 rn = 0;
	off = o.pc[0] & 0x000f;
	off |= 8; // A0-7
		off = sc->d[off];
		rn = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) rn = (s16)rn; // Rn.w
		off += (s8)ext + rn; // 8-bit signed offset + Rn
	}
	// EaRead : Read '($33,a0,d3.w*2)' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1f8] adda.l $3333.w, a0 ----------
static struct Sco Opd1f8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$3333.w':
	// Fetch Absolute Short address:
	off = (s16)o.pc[1];
	// EaRead : Read '$3333.w' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1f9] adda.l $33333333.l, a0 ----------
static struct Sco Opd1f9(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '$33333333.l':
	// Fetch Absolute Long address:
	off = (o.pc[1] << 16) | o.pc[2];
	// EaRead : Read '$33333333.l' into b:
	b = sc->read32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1fa] adda.l ($3333,pc), a0; =3335 ----------
static struct Sco Opd1fa(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($3333,pc)':
	off = (o.pc + 1 - sc->membase) << 1; // Get PC
	off += (s16)o.pc[1]; // Add on offset
	// EaRead : Read '($3333,pc)' into b:
	b = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 18;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1fb] adda.l ($33,pc,d3.w*2), a0; =35 ----------
static struct Sco Opd1fb(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaCalc : Get '($33,pc,d3.w*2)':
	{
		u32 ext = o.pc[1]; // Get extension word
		off = sc->d[(ext >> 12) & 0xf]; // Rn
		if ((ext & 0x800) == 0) off = (s16)off; // Rn.w
		off += (s8)ext; // 8-bit signed offset
		off += (o.pc + 1 - sc->membase) << 1; // Plus PC
	}
	// EaRead : Read '($33,pc,d3.w*2)' into b:
	b = sc->fetch32(off);

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 2;
	o.cycles -= 20;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [d1fc] adda.l #$33333333, a0 ----------
static struct Sco Opd1fc(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	u32 a = 0, b = 0;

	// EaRead : Read '#$33333333' into b:
	b = (o.pc[1] << 16) | o.pc[2]; // Fetch 32-bit value

	// EaCalc : Get register index into 'off':
	off = (o.pc[0] & 0x0e00) >> 9;
	off |= 8; // A0-7
	// EaRead : Read register[off] into a:
	a = sc->d[off];

	res = a + b;

	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	o.pc += 3;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e000] asr.b #8, d0 ----------
static struct Sco Ope000(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Arithmetic Shift register:
	res = (s32)val >> 8;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e008] lsr.b #8, d0 ----------
static struct Sco Ope008(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Shift register:
	res = ((u8)val) >> 8;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e010] roxr.b #8, d0 ----------
static struct Sco Ope010(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Rotate register:
	{
		u8 t = (u8)val;
		res = t; // (Rotate ends up doing nothing...)
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e018] ror.b #8, d0 ----------
static struct Sco Ope018(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Rotate register:
	{
		u8 t = (u8)val;
		res = t; // (Rotate ends up doing nothing...)
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e020] asr.b d0, d0 ----------
static struct Sco Ope020(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = (s32)val >> count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e028] lsr.b d0, d0 ----------
static struct Sco Ope028(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = ((u8)val) >> count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e030] roxr.b d0, d0 ----------
static struct Sco Ope030(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t << (8 - count)) | (t >> count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e038] ror.b d0, d0 ----------
static struct Sco Ope038(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t << (8 - count)) | (t >> count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e040] asr.w #8, d0 ----------
static struct Sco Ope040(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Arithmetic Shift register:
	res = (s32)val >> 8;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (8 - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e048] lsr.w #8, d0 ----------
static struct Sco Ope048(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Shift register:
	res = ((u16)val) >> 8;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (8 - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e050] roxr.w #8, d0 ----------
static struct Sco Ope050(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - 8)) | (t >> 8);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e058] ror.w #8, d0 ----------
static struct Sco Ope058(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - 8)) | (t >> 8);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e060] asr.w d0, d0 ----------
static struct Sco Ope060(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = (s32)val >> count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e068] lsr.w d0, d0 ----------
static struct Sco Ope068(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = ((u16)val) >> count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e070] roxr.w d0, d0 ----------
static struct Sco Ope070(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - count)) | (t >> count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e078] ror.w d0, d0 ----------
static struct Sco Ope078(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - count)) | (t >> count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e080] asr.l #8, d0 ----------
static struct Sco Ope080(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Arithmetic Shift register:
	res = (s32)val >> 8;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (8 - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e088] lsr.l #8, d0 ----------
static struct Sco Ope088(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Shift register:
	res = ((u32)val) >> 8;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (8 - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e090] roxr.l #8, d0 ----------
static struct Sco Ope090(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - 8)) | (t >> 8);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e098] ror.l #8, d0 ----------
static struct Sco Ope098(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - 8)) | (t >> 8);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e0a0] asr.l d0, d0 ----------
static struct Sco Ope0a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = (s32)val >> count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e0a8] lsr.l d0, d0 ----------
static struct Sco Ope0a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = ((u32)val) >> count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e0b0] roxr.l d0, d0 ----------
static struct Sco Ope0b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - count)) | (t >> count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e0b8] ror.l d0, d0 ----------
static struct Sco Ope0b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - count)) | (t >> count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e100] asl.b #8, d0 ----------
static struct Sco Ope100(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Arithmetic Shift register:
	res = val << 8;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - 8)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e108] lsl.b #8, d0 ----------
static struct Sco Ope108(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Shift register:
	res = val << 8;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - 8)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e110] roxl.b #8, d0 ----------
static struct Sco Ope110(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Rotate register:
	{
		u8 t = (u8)val;
		res = t; // (Rotate ends up doing nothing...)
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e118] rol.b #8, d0 ----------
static struct Sco Ope118(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Rotate register:
	{
		u8 t = (u8)val;
		res = t; // (Rotate ends up doing nothing...)
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e120] asl.b d0, d0 ----------
static struct Sco Ope120(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = val << count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e128] lsl.b d0, d0 ----------
static struct Sco Ope128(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = val << count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e130] roxl.b d0, d0 ----------
static struct Sco Ope130(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t >> (8 - count)) | (t << count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e138] rol.b d0, d0 ----------
static struct Sco Ope138(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t >> (8 - count)) | (t << count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e140] asl.w #8, d0 ----------
static struct Sco Ope140(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Arithmetic Shift register:
	res = val << 8;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (16 - 8)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e148] lsl.w #8, d0 ----------
static struct Sco Ope148(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Shift register:
	res = val << 8;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (16 - 8)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e150] roxl.w #8, d0 ----------
static struct Sco Ope150(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - 8)) | (t << 8);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e158] rol.w #8, d0 ----------
static struct Sco Ope158(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - 8)) | (t << 8);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 22;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e160] asl.w d0, d0 ----------
static struct Sco Ope160(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = val << count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (16 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e168] lsl.w d0, d0 ----------
static struct Sco Ope168(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = val << count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (16 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e170] roxl.w d0, d0 ----------
static struct Sco Ope170(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - count)) | (t << count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e178] rol.w d0, d0 ----------
static struct Sco Ope178(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - count)) | (t << count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e180] asl.l #8, d0 ----------
static struct Sco Ope180(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Arithmetic Shift register:
	res = val << 8;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (32 - 8)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e188] lsl.l #8, d0 ----------
static struct Sco Ope188(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Shift register:
	res = val << 8;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (32 - 8)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e190] roxl.l #8, d0 ----------
static struct Sco Ope190(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - 8)) | (t << 8);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e198] rol.l #8, d0 ----------
static struct Sco Ope198(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - 8)) | (t << 8);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 24;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e1a0] asl.l d0, d0 ----------
static struct Sco Ope1a0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = val << count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (32 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e1a8] lsl.l d0, d0 ----------
static struct Sco Ope1a8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = val << count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (32 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e1b0] roxl.l d0, d0 ----------
static struct Sco Ope1b0(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - count)) | (t << count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e1b8] rol.l d0, d0 ----------
static struct Sco Ope1b8(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	{
		// Use Dn for count:
		u32 n = (o.pc[0] & 0xe00) >> 9;
		count = sc->d[n] & 63;
	}

	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - count)) | (t << count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e210] roxr.b #1, d0 ----------
static struct Sco Ope210(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t << (8 - 1)) | (t >> 1);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e250] roxr.w #1, d0 ----------
static struct Sco Ope250(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - 1)) | (t >> 1);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e290] roxr.l #1, d0 ----------
static struct Sco Ope290(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - 1)) | (t >> 1);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e310] roxl.b #1, d0 ----------
static struct Sco Ope310(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t >> (8 - 1)) | (t << 1);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e350] roxl.w #1, d0 ----------
static struct Sco Ope350(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - 1)) | (t << 1);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [e390] roxl.l #1, d0 ----------
static struct Sco Ope390(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - 1)) | (t << 1);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 10;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee00] asr.b #7, d0 ----------
static struct Sco Opee00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = (s32)val >> count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee08] lsr.b #7, d0 ----------
static struct Sco Opee08(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = ((u8)val) >> count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee10] roxr.b #7, d0 ----------
static struct Sco Opee10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t << (8 - count)) | (t >> count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee18] ror.b #7, d0 ----------
static struct Sco Opee18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t << (8 - count)) | (t >> count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee40] asr.w #7, d0 ----------
static struct Sco Opee40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = (s32)val >> count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee48] lsr.w #7, d0 ----------
static struct Sco Opee48(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = ((u16)val) >> count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee50] roxr.w #7, d0 ----------
static struct Sco Opee50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - count)) | (t >> count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee58] ror.w #7, d0 ----------
static struct Sco Opee58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t << (16 - count)) | (t >> count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee80] asr.l #7, d0 ----------
static struct Sco Opee80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = (s32)val >> count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee88] lsr.l #7, d0 ----------
static struct Sco Opee88(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = ((u32)val) >> count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (count - 1)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee90] roxr.l #7, d0 ----------
static struct Sco Opee90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - count)) | (t >> count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ee98] ror.l #7, d0 ----------
static struct Sco Opee98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t << (32 - count)) | (t >> count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef00] asl.b #7, d0 ----------
static struct Sco Opef00(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = val << count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef08] lsl.b #7, d0 ----------
static struct Sco Opef08(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = val << count;

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80) o.sr |= 2; // V
	o.sr |= (val >> (8 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef10] roxl.b #7, d0 ----------
static struct Sco Opef10(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t >> (8 - count)) | (t << count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef18] rol.b #7, d0 ----------
static struct Sco Opef18(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s8)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u8 t = (u8)val;
		res = (t >> (8 - count)) | (t << count);
	}

	res &= 0xff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 4) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xff;
	sc->d[off] |= res & 0xff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef40] asl.w #7, d0 ----------
static struct Sco Opef40(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = val << count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (16 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef48] lsl.w #7, d0 ----------
static struct Sco Opef48(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = val << count;

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x8000) o.sr |= 2; // V
	o.sr |= (val >> (16 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef50] roxl.w #7, d0 ----------
static struct Sco Opef50(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - count)) | (t << count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef58] rol.w #7, d0 ----------
static struct Sco Opef58(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = (s16)sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u16 t = (u16)val;
		res = (t >> (16 - count)) | (t << count);
	}

	res &= 0xffff;
	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 12) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] &= ~0xffff;
	sc->d[off] |= res & 0xffff;

	(void)count;
	o.pc += 1;
	o.cycles -= 6;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef80] asl.l #7, d0 ----------
static struct Sco Opef80(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Arithmetic Shift register:
	res = val << count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (32 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef88] lsl.l #7, d0 ----------
static struct Sco Opef88(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Shift register:
	res = val << count;

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	if ((val ^ res) & 0x80000000) o.sr |= 2; // V
	o.sr |= (val >> (32 - count)) & 1; // C
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef90] roxl.l #7, d0 ----------
static struct Sco Opef90(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - count)) | (t << count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}

// ---------- [ef98] rol.l #7, d0 ----------
static struct Sco Opef98(struct Sco o, struct Scour *sc)
{
	u32 off = 0, val = 0, res = 0;

	int count = 0;

	// EaCalc : Get register index into 'off':
	off = o.pc[0] & 0x0007;
	// EaRead : Read register[off] into val:
	val = sc->d[off];

	count = (o.pc[0] & 0xe00) >> 9;
	o.cycles -= (count << 1); // Take 2*n cycles

	// Rotate register:
	{
		u32 t = (u32)val;
		res = (t >> (32 - count)) | (t << count);
	}

	o.sr &= ~0xf; // Clear NZVC
	o.sr |= (res >> 28) & 8; // N
	if (res == 0) o.sr |= 4; // Z
	o.sr |= res & 1;
	// EaWrite : Write res into register[off]:
	sc->d[off] = res;

	(void)count;
	o.pc += 1;
	o.cycles -= 8;
	(void)sc; (void)off; (void)val; (void)res;

	return o;
}


ScopFunc ScopTable[0x10000] = {
	Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000, // 0000
	Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0018,Op0018,Op0018,Op0018,Op0018,Op0018,Op0018,Op001f, // 0010
	Op0020,Op0020,Op0020,Op0020,Op0020,Op0020,Op0020,Op0027,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028, // 0020
	Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0038,Op0039,Op003a,Op003b,Op003c,Op____,Op____,Op____, // 0030
	Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040, // 0040
	Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0058,Op0058,Op0058,Op0058,Op0058,Op0058,Op0058,Op005f, // 0050
	Op0060,Op0060,Op0060,Op0060,Op0060,Op0060,Op0060,Op0067,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068, // 0060
	Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0078,Op0079,Op007a,Op007b,Op007c,Op____,Op____,Op____, // 0070
	Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080, // 0080
	Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0098,Op0098,Op0098,Op0098,Op0098,Op0098,Op0098,Op009f, // 0090
	Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a7,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8, // 00a0
	Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b8,Op00b9,Op00ba,Op00bb,Op____,Op____,Op____,Op____, // 00b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 00c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 00d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 00e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 00f0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0100
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0110
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0120
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0130
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0140
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0150
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0160
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0170
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0180
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0190
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 01a0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 01b0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 01c0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 01d0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 01e0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 01f0
	Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200, // 0200
	Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0218,Op0218,Op0218,Op0218,Op0218,Op0218,Op0218,Op021f, // 0210
	Op0220,Op0220,Op0220,Op0220,Op0220,Op0220,Op0220,Op0227,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228, // 0220
	Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0238,Op0239,Op023a,Op023b,Op023c,Op____,Op____,Op____, // 0230
	Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240, // 0240
	Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0258,Op0258,Op0258,Op0258,Op0258,Op0258,Op0258,Op025f, // 0250
	Op0260,Op0260,Op0260,Op0260,Op0260,Op0260,Op0260,Op0267,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268, // 0260
	Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0278,Op0279,Op027a,Op027b,Op027c,Op____,Op____,Op____, // 0270
	Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280, // 0280
	Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0298,Op0298,Op0298,Op0298,Op0298,Op0298,Op0298,Op029f, // 0290
	Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a7,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8, // 02a0
	Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b8,Op02b9,Op02ba,Op02bb,Op____,Op____,Op____,Op____, // 02b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 02c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 02d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 02e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 02f0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0300
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0310
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0320
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0330
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0340
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0350
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0360
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0370
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0380
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0390
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 03a0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 03b0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 03c0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 03d0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 03e0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 03f0
	Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400, // 0400
	Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0418,Op0418,Op0418,Op0418,Op0418,Op0418,Op0418,Op041f, // 0410
	Op0420,Op0420,Op0420,Op0420,Op0420,Op0420,Op0420,Op0427,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428, // 0420
	Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0438,Op0439,Op043a,Op043b,Op____,Op____,Op____,Op____, // 0430
	Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440, // 0440
	Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0458,Op0458,Op0458,Op0458,Op0458,Op0458,Op0458,Op045f, // 0450
	Op0460,Op0460,Op0460,Op0460,Op0460,Op0460,Op0460,Op0467,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468, // 0460
	Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0478,Op0479,Op047a,Op047b,Op____,Op____,Op____,Op____, // 0470
	Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480, // 0480
	Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0498,Op0498,Op0498,Op0498,Op0498,Op0498,Op0498,Op049f, // 0490
	Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a7,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8, // 04a0
	Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b8,Op04b9,Op04ba,Op04bb,Op____,Op____,Op____,Op____, // 04b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 04c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 04d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 04e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 04f0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0500
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0510
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0520
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0530
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0540
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0550
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0560
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0570
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0580
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0590
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 05a0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 05b0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 05c0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 05d0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 05e0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 05f0
	Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600, // 0600
	Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0618,Op0618,Op0618,Op0618,Op0618,Op0618,Op0618,Op061f, // 0610
	Op0620,Op0620,Op0620,Op0620,Op0620,Op0620,Op0620,Op0627,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628, // 0620
	Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0638,Op0639,Op063a,Op063b,Op____,Op____,Op____,Op____, // 0630
	Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640, // 0640
	Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0658,Op0658,Op0658,Op0658,Op0658,Op0658,Op0658,Op065f, // 0650
	Op0660,Op0660,Op0660,Op0660,Op0660,Op0660,Op0660,Op0667,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668, // 0660
	Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0678,Op0679,Op067a,Op067b,Op____,Op____,Op____,Op____, // 0670
	Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680, // 0680
	Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0698,Op0698,Op0698,Op0698,Op0698,Op0698,Op0698,Op069f, // 0690
	Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a7,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8, // 06a0
	Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b8,Op06b9,Op06ba,Op06bb,Op____,Op____,Op____,Op____, // 06b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 06c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 06d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 06e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 06f0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0700
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0710
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0720
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0730
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0740
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0750
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0760
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0770
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0780
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0790
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 07a0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 07b0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 07c0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 07d0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 07e0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 07f0
	Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800, // 0800
	Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0818,Op0818,Op0818,Op0818,Op0818,Op0818,Op0818,Op081f, // 0810
	Op0820,Op0820,Op0820,Op0820,Op0820,Op0820,Op0820,Op0827,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828, // 0820
	Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0838,Op0839,Op083a,Op083b,Op083c,Op____,Op____,Op____, // 0830
	Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840, // 0840
	Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0858,Op0858,Op0858,Op0858,Op0858,Op0858,Op0858,Op085f, // 0850
	Op0860,Op0860,Op0860,Op0860,Op0860,Op0860,Op0860,Op0867,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868, // 0860
	Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0878,Op0879,Op087a,Op087b,Op____,Op____,Op____,Op____, // 0870
	Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880, // 0880
	Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0898,Op0898,Op0898,Op0898,Op0898,Op0898,Op0898,Op089f, // 0890
	Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a7,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8, // 08a0
	Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b8,Op08b9,Op08ba,Op08bb,Op____,Op____,Op____,Op____, // 08b0
	Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0, // 08c0
	Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08df, // 08d0
	Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e7,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8, // 08e0
	Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f8,Op08f9,Op08fa,Op08fb,Op____,Op____,Op____,Op____, // 08f0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0900
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0910
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0920
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0930
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0940
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0950
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0960
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0970
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0980
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0990
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 09a0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 09b0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 09c0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 09d0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 09e0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 09f0
	Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00, // 0a00
	Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a1f, // 0a10
	Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a27,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28, // 0a20
	Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a38,Op0a39,Op0a3a,Op0a3b,Op0a3c,Op____,Op____,Op____, // 0a30
	Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40, // 0a40
	Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a5f, // 0a50
	Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a67,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68, // 0a60
	Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a78,Op0a79,Op0a7a,Op0a7b,Op0a7c,Op____,Op____,Op____, // 0a70
	Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80, // 0a80
	Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a9f, // 0a90
	Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa7,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8, // 0aa0
	Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab8,Op0ab9,Op0aba,Op0abb,Op____,Op____,Op____,Op____, // 0ab0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ac0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ad0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ae0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0af0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0b00
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0b10
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0b20
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0b30
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0b40
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0b50
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0b60
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0b70
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0b80
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0b90
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 0ba0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 0bb0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0bc0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 0bd0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 0be0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 0bf0
	Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00, // 0c00
	Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c1f, // 0c10
	Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c27,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28, // 0c20
	Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c38,Op0c39,Op0c3a,Op0c3b,Op0c3c,Op____,Op____,Op____, // 0c30
	Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40, // 0c40
	Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c5f, // 0c50
	Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c67,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68, // 0c60
	Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c78,Op0c79,Op0c7a,Op0c7b,Op0c7c,Op____,Op____,Op____, // 0c70
	Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80, // 0c80
	Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c9f, // 0c90
	Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca7,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8, // 0ca0
	Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb8,Op0cb9,Op0cba,Op0cbb,Op0cbc,Op____,Op____,Op____, // 0cb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0cc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0cd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ce0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0cf0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0d00
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0d10
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0d20
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0d30
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0d40
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0d50
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0d60
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0d70
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0d80
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0d90
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 0da0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 0db0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0dc0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 0dd0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 0de0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 0df0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0e90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ea0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0eb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ec0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ed0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ee0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0ef0
	Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0f00
	Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f, // 0f10
	Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128, // 0f20
	Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____, // 0f30
	Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0f40
	Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f, // 0f50
	Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168, // 0f60
	Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0178,Op0179,Op017a,Op017b,Op____,Op____,Op____,Op____, // 0f70
	Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0f80
	Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f, // 0f90
	Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8, // 0fa0
	Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b8,Op01b9,Op01ba,Op01bb,Op____,Op____,Op____,Op____, // 0fb0
	Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 0fc0
	Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df, // 0fd0
	Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8, // 0fe0
	Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f8,Op01f9,Op01fa,Op01fb,Op____,Op____,Op____,Op____, // 0ff0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1000
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1010
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1020
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1030
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1040
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1050
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1060
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1070
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1080
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1090
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 10a0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 10b0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 10c0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 10d0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 10e0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 10f0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1100
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1110
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1120
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1130
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1140
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1150
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1160
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1170
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1180
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1190
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 11a0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 11b0
	Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0, // 11c0
	Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11df, // 11d0
	Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e7,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8, // 11e0
	Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f8,Op11f9,Op11fa,Op11fb,Op11fc,Op____,Op____,Op____, // 11f0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1200
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1210
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1220
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1230
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1240
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1250
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1260
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1270
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1280
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1290
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 12a0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 12b0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 12c0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 12d0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 12e0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 12f0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1300
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1310
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1320
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1330
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1340
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1350
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1360
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1370
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1380
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1390
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 13a0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 13b0
	Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0, // 13c0
	Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13df, // 13d0
	Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e7,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8, // 13e0
	Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f8,Op13f9,Op13fa,Op13fb,Op13fc,Op____,Op____,Op____, // 13f0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1400
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1410
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1420
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1430
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1440
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1450
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1460
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1470
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1480
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1490
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 14a0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 14b0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 14c0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 14d0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 14e0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 14f0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1500
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1510
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1520
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1530
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1540
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1550
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1560
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1570
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1580
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1590
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 15a0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 15b0
	Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0,Op15c0, // 15c0
	Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d0,Op15d8,Op15d8,Op15d8,Op15d8,Op15d8,Op15d8,Op15d8,Op15df, // 15d0
	Op15e0,Op15e0,Op15e0,Op15e0,Op15e0,Op15e0,Op15e0,Op15e7,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8,Op15e8, // 15e0
	Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f0,Op15f8,Op15f9,Op15fa,Op15fb,Op15fc,Op____,Op____,Op____, // 15f0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1600
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1610
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1620
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1630
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1640
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1650
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1660
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1670
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1680
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1690
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 16a0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 16b0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 16c0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 16d0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 16e0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 16f0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1700
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1710
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1720
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1730
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1740
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1750
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1760
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1770
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1780
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1790
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 17a0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 17b0
	Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0,Op17c0, // 17c0
	Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d0,Op17d8,Op17d8,Op17d8,Op17d8,Op17d8,Op17d8,Op17d8,Op17df, // 17d0
	Op17e0,Op17e0,Op17e0,Op17e0,Op17e0,Op17e0,Op17e0,Op17e7,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8,Op17e8, // 17e0
	Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f0,Op17f8,Op17f9,Op17fa,Op17fb,Op17fc,Op____,Op____,Op____, // 17f0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1800
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1810
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1820
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1830
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1840
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1850
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1860
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1870
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1880
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1890
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 18a0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 18b0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 18c0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 18d0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 18e0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 18f0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1900
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1910
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1920
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1930
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1940
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1950
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1960
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1970
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1980
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1990
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 19a0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 19b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 19c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 19d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 19e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 19f0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1a00
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1a10
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1a20
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1a30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1a40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1a50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1a60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1a70
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1a80
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1a90
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 1aa0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 1ab0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 1ac0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 1ad0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 1ae0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 1af0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1b00
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1b10
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1b20
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1b30
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1b40
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1b50
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1b60
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1b70
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1b80
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1b90
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 1ba0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 1bb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1bc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1bd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1be0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1bf0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1c00
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1c10
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1c20
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1c30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1c40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1c50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1c60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1c70
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1c80
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1c90
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 1ca0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 1cb0
	Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0, // 1cc0
	Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df, // 1cd0
	Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8, // 1ce0
	Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____, // 1cf0
	Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100, // 1d00
	Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f, // 1d10
	Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128, // 1d20
	Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____, // 1d30
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1d40
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1d50
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1d60
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1d70
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1d80
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1d90
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 1da0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 1db0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1dc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1dd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1de0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1df0
	Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000, // 1e00
	Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f, // 1e10
	Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028, // 1e20
	Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____, // 1e30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1e40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1e50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1e60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1e70
	Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080, // 1e80
	Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f, // 1e90
	Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8, // 1ea0
	Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____, // 1eb0
	Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0, // 1ec0
	Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1edf, // 1ed0
	Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee7,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8, // 1ee0
	Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef8,Op1ef9,Op1efa,Op1efb,Op1efc,Op____,Op____,Op____, // 1ef0
	Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00, // 1f00
	Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f1f, // 1f10
	Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f27,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28, // 1f20
	Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f38,Op1f39,Op1f3a,Op1f3b,Op1f3c,Op____,Op____,Op____, // 1f30
	Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140, // 1f40
	Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f, // 1f50
	Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168, // 1f60
	Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____, // 1f70
	Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180, // 1f80
	Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f, // 1f90
	Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8, // 1fa0
	Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____, // 1fb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1fc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1fd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1fe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 1ff0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2000
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2010
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2020
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2030
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2040
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2050
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2060
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2070
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2080
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2090
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 20a0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 20b0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 20c0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 20d0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 20e0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 20f0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2100
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2110
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2120
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2130
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2140
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2150
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2160
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2170
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2180
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2190
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 21a0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 21b0
	Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0, // 21c0
	Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21df, // 21d0
	Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e7,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8, // 21e0
	Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f8,Op21f9,Op21fa,Op21fb,Op21fc,Op____,Op____,Op____, // 21f0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2200
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2210
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2220
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2230
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2240
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2250
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2260
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2270
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2280
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2290
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 22a0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 22b0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 22c0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 22d0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 22e0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 22f0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2300
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2310
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2320
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2330
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2340
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2350
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2360
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2370
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2380
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2390
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 23a0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 23b0
	Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0, // 23c0
	Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23df, // 23d0
	Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e7,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8, // 23e0
	Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f8,Op23f9,Op23fa,Op23fb,Op23fc,Op____,Op____,Op____, // 23f0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2400
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2410
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2420
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2430
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2440
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2450
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2460
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2470
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2480
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2490
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 24a0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 24b0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 24c0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 24d0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 24e0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 24f0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2500
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2510
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2520
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2530
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2540
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2550
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2560
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2570
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2580
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2590
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 25a0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 25b0
	Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0,Op25c0, // 25c0
	Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d0,Op25d8,Op25d8,Op25d8,Op25d8,Op25d8,Op25d8,Op25d8,Op25df, // 25d0
	Op25e0,Op25e0,Op25e0,Op25e0,Op25e0,Op25e0,Op25e0,Op25e7,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8,Op25e8, // 25e0
	Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f0,Op25f8,Op25f9,Op25fa,Op25fb,Op25fc,Op____,Op____,Op____, // 25f0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2600
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2610
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2620
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2630
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2640
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2650
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2660
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2670
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2680
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2690
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 26a0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 26b0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 26c0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 26d0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 26e0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 26f0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2700
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2710
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2720
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2730
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2740
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2750
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2760
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2770
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2780
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2790
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 27a0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 27b0
	Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0,Op27c0, // 27c0
	Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d0,Op27d8,Op27d8,Op27d8,Op27d8,Op27d8,Op27d8,Op27d8,Op27df, // 27d0
	Op27e0,Op27e0,Op27e0,Op27e0,Op27e0,Op27e0,Op27e0,Op27e7,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8,Op27e8, // 27e0
	Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f0,Op27f8,Op27f9,Op27fa,Op27fb,Op27fc,Op____,Op____,Op____, // 27f0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2800
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2810
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2820
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2830
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2840
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2850
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2860
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2870
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2880
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2890
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 28a0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 28b0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 28c0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 28d0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 28e0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 28f0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2900
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2910
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2920
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2930
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2940
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2950
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2960
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2970
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2980
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2990
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 29a0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 29b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 29c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 29d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 29e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 29f0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2a00
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2a10
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2a20
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2a30
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2a40
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2a50
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2a60
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2a70
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2a80
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2a90
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 2aa0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 2ab0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 2ac0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 2ad0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 2ae0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 2af0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2b00
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2b10
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2b20
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2b30
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2b40
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2b50
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2b60
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2b70
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2b80
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2b90
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 2ba0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 2bb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2bc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2bd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2be0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2bf0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2c00
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2c10
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2c20
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2c30
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2c40
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2c50
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2c60
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2c70
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2c80
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2c90
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 2ca0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 2cb0
	Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0, // 2cc0
	Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20df, // 2cd0
	Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e7,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8, // 2ce0
	Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____, // 2cf0
	Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100, // 2d00
	Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op211f, // 2d10
	Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2127,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128, // 2d20
	Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____, // 2d30
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2d40
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2d50
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2d60
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2d70
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2d80
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2d90
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 2da0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 2db0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2dc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2dd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2de0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2df0
	Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000, // 2e00
	Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op201f, // 2e10
	Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2027,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028, // 2e20
	Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____, // 2e30
	Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040, // 2e40
	Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op205f, // 2e50
	Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2067,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068, // 2e60
	Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____, // 2e70
	Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080, // 2e80
	Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op209f, // 2e90
	Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a7,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8, // 2ea0
	Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____, // 2eb0
	Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0, // 2ec0
	Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2edf, // 2ed0
	Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee7,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8, // 2ee0
	Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef8,Op2ef9,Op2efa,Op2efb,Op2efc,Op____,Op____,Op____, // 2ef0
	Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00, // 2f00
	Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f1f, // 2f10
	Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f27,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28, // 2f20
	Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f38,Op2f39,Op2f3a,Op2f3b,Op2f3c,Op____,Op____,Op____, // 2f30
	Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140, // 2f40
	Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op215f, // 2f50
	Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2167,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168, // 2f60
	Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____, // 2f70
	Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180, // 2f80
	Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op219f, // 2f90
	Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a7,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8, // 2fa0
	Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____, // 2fb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2fc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2fd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2fe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 2ff0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3000
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3010
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3020
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3030
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3040
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3050
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3060
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3070
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3080
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3090
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 30a0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 30b0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 30c0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 30d0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 30e0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 30f0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3100
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3110
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3120
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3130
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3140
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3150
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3160
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3170
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3180
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3190
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 31a0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 31b0
	Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0, // 31c0
	Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31df, // 31d0
	Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e7,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8, // 31e0
	Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f8,Op31f9,Op31fa,Op31fb,Op31fc,Op____,Op____,Op____, // 31f0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3200
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3210
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3220
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3230
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3240
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3250
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3260
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3270
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3280
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3290
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 32a0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 32b0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 32c0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 32d0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 32e0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 32f0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3300
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3310
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3320
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3330
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3340
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3350
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3360
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3370
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3380
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3390
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 33a0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 33b0
	Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0, // 33c0
	Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33df, // 33d0
	Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e7,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8, // 33e0
	Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f8,Op33f9,Op33fa,Op33fb,Op33fc,Op____,Op____,Op____, // 33f0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3400
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3410
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3420
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3430
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3440
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3450
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3460
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3470
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3480
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3490
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 34a0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 34b0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 34c0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 34d0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 34e0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 34f0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3500
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3510
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3520
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3530
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3540
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3550
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3560
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3570
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3580
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3590
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 35a0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 35b0
	Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0,Op35c0, // 35c0
	Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d0,Op35d8,Op35d8,Op35d8,Op35d8,Op35d8,Op35d8,Op35d8,Op35df, // 35d0
	Op35e0,Op35e0,Op35e0,Op35e0,Op35e0,Op35e0,Op35e0,Op35e7,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8,Op35e8, // 35e0
	Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f0,Op35f8,Op35f9,Op35fa,Op35fb,Op35fc,Op____,Op____,Op____, // 35f0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3600
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3610
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3620
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3630
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3640
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3650
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3660
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3670
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3680
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3690
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 36a0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 36b0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 36c0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 36d0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 36e0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 36f0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3700
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3710
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3720
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3730
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3740
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3750
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3760
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3770
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3780
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3790
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 37a0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 37b0
	Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0,Op37c0, // 37c0
	Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d0,Op37d8,Op37d8,Op37d8,Op37d8,Op37d8,Op37d8,Op37d8,Op37df, // 37d0
	Op37e0,Op37e0,Op37e0,Op37e0,Op37e0,Op37e0,Op37e0,Op37e7,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8,Op37e8, // 37e0
	Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f0,Op37f8,Op37f9,Op37fa,Op37fb,Op37fc,Op____,Op____,Op____, // 37f0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3800
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3810
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3820
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3830
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3840
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3850
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3860
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3870
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3880
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3890
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 38a0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 38b0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 38c0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 38d0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 38e0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 38f0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3900
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3910
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3920
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3930
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3940
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3950
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3960
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3970
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3980
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3990
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 39a0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 39b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 39c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 39d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 39e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 39f0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3a00
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3a10
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3a20
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3a30
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3a40
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3a50
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3a60
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3a70
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3a80
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3a90
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 3aa0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 3ab0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 3ac0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 3ad0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 3ae0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 3af0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3b00
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3b10
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3b20
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3b30
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3b40
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3b50
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3b60
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3b70
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3b80
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3b90
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 3ba0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 3bb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3bc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3bd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3be0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3bf0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3c00
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3c10
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3c20
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3c30
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3c40
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3c50
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3c60
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3c70
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3c80
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3c90
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 3ca0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 3cb0
	Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0, // 3cc0
	Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30df, // 3cd0
	Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e7,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8, // 3ce0
	Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____, // 3cf0
	Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100, // 3d00
	Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op311f, // 3d10
	Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3127,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128, // 3d20
	Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____, // 3d30
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3d40
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3d50
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3d60
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3d70
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3d80
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3d90
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 3da0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 3db0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3dc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3dd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3de0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3df0
	Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000, // 3e00
	Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op301f, // 3e10
	Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3027,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028, // 3e20
	Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____, // 3e30
	Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040, // 3e40
	Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op305f, // 3e50
	Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3067,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068, // 3e60
	Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____, // 3e70
	Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080, // 3e80
	Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op309f, // 3e90
	Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a7,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8, // 3ea0
	Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____, // 3eb0
	Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0, // 3ec0
	Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3edf, // 3ed0
	Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee7,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8, // 3ee0
	Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef8,Op3ef9,Op3efa,Op3efb,Op3efc,Op____,Op____,Op____, // 3ef0
	Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00, // 3f00
	Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f1f, // 3f10
	Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f27,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28, // 3f20
	Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f38,Op3f39,Op3f3a,Op3f3b,Op3f3c,Op____,Op____,Op____, // 3f30
	Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140, // 3f40
	Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op315f, // 3f50
	Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3167,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168, // 3f60
	Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____, // 3f70
	Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180, // 3f80
	Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op319f, // 3f90
	Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a7,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8, // 3fa0
	Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____, // 3fb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3fc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3fd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3fe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 3ff0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4000
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4010
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4020
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4030
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4040
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4050
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4060
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4070
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4080
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4090
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 40a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 40b0
	Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 40c0
	Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40df, // 40d0
	Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e7,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8, // 40e0
	Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f8,Op40f9,Op40fa,Op40fb,Op____,Op____,Op____,Op____, // 40f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4100
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4110
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4120
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4130
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4140
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4150
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4160
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4170
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4180
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4190
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 41a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 41b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 41c0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 41d0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 41e0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 41f0
	Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200, // 4200
	Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4218,Op4218,Op4218,Op4218,Op4218,Op4218,Op4218,Op421f, // 4210
	Op4220,Op4220,Op4220,Op4220,Op4220,Op4220,Op4220,Op4227,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228, // 4220
	Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4238,Op4239,Op423a,Op423b,Op____,Op____,Op____,Op____, // 4230
	Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240, // 4240
	Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4258,Op4258,Op4258,Op4258,Op4258,Op4258,Op4258,Op425f, // 4250
	Op4260,Op4260,Op4260,Op4260,Op4260,Op4260,Op4260,Op4267,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268, // 4260
	Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4278,Op4279,Op427a,Op427b,Op____,Op____,Op____,Op____, // 4270
	Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280, // 4280
	Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4298,Op4298,Op4298,Op4298,Op4298,Op4298,Op4298,Op429f, // 4290
	Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a7,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8, // 42a0
	Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b8,Op42b9,Op42ba,Op42bb,Op____,Op____,Op____,Op____, // 42b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 42c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 42d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 42e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 42f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4300
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4310
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4320
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4330
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4340
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4350
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4360
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4370
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4380
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4390
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 43a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 43b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 43c0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 43d0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 43e0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 43f0
	Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400, // 4400
	Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4418,Op4418,Op4418,Op4418,Op4418,Op4418,Op4418,Op441f, // 4410
	Op4420,Op4420,Op4420,Op4420,Op4420,Op4420,Op4420,Op4427,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428, // 4420
	Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4438,Op4439,Op443a,Op443b,Op____,Op____,Op____,Op____, // 4430
	Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440, // 4440
	Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4458,Op4458,Op4458,Op4458,Op4458,Op4458,Op4458,Op445f, // 4450
	Op4460,Op4460,Op4460,Op4460,Op4460,Op4460,Op4460,Op4467,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468, // 4460
	Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4478,Op4479,Op447a,Op447b,Op____,Op____,Op____,Op____, // 4470
	Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480, // 4480
	Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4498,Op4498,Op4498,Op4498,Op4498,Op4498,Op4498,Op449f, // 4490
	Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a7,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8, // 44a0
	Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b8,Op44b9,Op44ba,Op44bb,Op____,Op____,Op____,Op____, // 44b0
	Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 44c0
	Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44df, // 44d0
	Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e7,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8, // 44e0
	Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f8,Op44f9,Op44fa,Op44fb,Op44fc,Op____,Op____,Op____, // 44f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4500
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4510
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4520
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4530
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4540
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4550
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4560
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4570
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4580
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4590
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 45a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 45b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 45c0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 45d0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 45e0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 45f0
	Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600, // 4600
	Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4618,Op4618,Op4618,Op4618,Op4618,Op4618,Op4618,Op461f, // 4610
	Op4620,Op4620,Op4620,Op4620,Op4620,Op4620,Op4620,Op4627,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628, // 4620
	Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4638,Op4639,Op463a,Op463b,Op____,Op____,Op____,Op____, // 4630
	Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640, // 4640
	Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4658,Op4658,Op4658,Op4658,Op4658,Op4658,Op4658,Op465f, // 4650
	Op4660,Op4660,Op4660,Op4660,Op4660,Op4660,Op4660,Op4667,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668, // 4660
	Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4678,Op4679,Op467a,Op467b,Op____,Op____,Op____,Op____, // 4670
	Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680, // 4680
	Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4698,Op4698,Op4698,Op4698,Op4698,Op4698,Op4698,Op469f, // 4690
	Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a7,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8, // 46a0
	Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b8,Op46b9,Op46ba,Op46bb,Op____,Op____,Op____,Op____, // 46b0
	Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 46c0
	Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46df, // 46d0
	Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e7,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8, // 46e0
	Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f8,Op46f9,Op46fa,Op46fb,Op46fc,Op____,Op____,Op____, // 46f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4700
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4710
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4720
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4730
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4740
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4750
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4760
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4770
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4780
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4790
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 47a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 47b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 47c0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 47d0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 47e0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 47f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4800
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4810
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4820
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4830
	Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4840
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4850
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4860
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4870
	Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4880
	Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4898,Op4898,Op4898,Op4898,Op4898,Op4898,Op4898,Op489f, // 4890
	Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a7,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 48a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 48b0
	Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 48c0
	Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d8,Op48d8,Op48d8,Op48d8,Op48d8,Op48d8,Op48d8,Op48df, // 48d0
	Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e7,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 48e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 48f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4900
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4910
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4920
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4930
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4940
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4950
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4960
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4970
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4980
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4990
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 49a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 49b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 49c0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 49d0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 49e0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 49f0
	Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00, // 4a00
	Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a1f, // 4a10
	Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a27,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28, // 4a20
	Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a38,Op4a39,Op4a3a,Op4a3b,Op4a3c,Op____,Op____,Op____, // 4a30
	Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40, // 4a40
	Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a5f, // 4a50
	Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a67,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68, // 4a60
	Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a78,Op4a79,Op4a7a,Op4a7b,Op4a7c,Op____,Op____,Op____, // 4a70
	Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80, // 4a80
	Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a9f, // 4a90
	Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa7,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8, // 4aa0
	Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab8,Op4ab9,Op4aba,Op4abb,Op4abc,Op____,Op____,Op____, // 4ab0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ac0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ad0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ae0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4af0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4b90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ba0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4bb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4bc0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 4bd0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 4be0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 4bf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4c80
	Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c9f, // 4c90
	Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca0,Op4ca7,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ca0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4cb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4cc0
	Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cdf, // 4cd0
	Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce0,Op4ce7,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ce0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4cf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4d90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4da0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4db0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4dc0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 4dd0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 4de0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 4df0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e40
	Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58, // 4e50
	Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68, // 4e60
	Op____,Op4e71,Op____,Op4e73,Op____,Op4e75,Op____,Op4e77,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4e80
	Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e98,Op4e98,Op4e98,Op4e98,Op4e98,Op4e98,Op4e98,Op4e9f, // 4e90
	Op4ea0,Op4ea0,Op4ea0,Op4ea0,Op4ea0,Op4ea0,Op4ea0,Op4ea7,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8, // 4ea0
	Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb8,Op4eb9,Op4eba,Op4ebb,Op4ebc,Op____,Op____,Op____, // 4eb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4ec0
	Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed8,Op4ed8,Op4ed8,Op4ed8,Op4ed8,Op4ed8,Op4ed8,Op4edf, // 4ed0
	Op4ee0,Op4ee0,Op4ee0,Op4ee0,Op4ee0,Op4ee0,Op4ee0,Op4ee7,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8, // 4ee0
	Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef8,Op4ef9,Op4efa,Op4efb,Op4efc,Op____,Op____,Op____, // 4ef0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4f90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4fa0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4fb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 4fc0
	Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41d8,Op41df, // 4fd0
	Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e0,Op41e7,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8, // 4fe0
	Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f8,Op41f9,Op41fa,Op41fb,Op41fc,Op____,Op____,Op____, // 4ff0
	Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008, // 5000
	Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5018,Op5018,Op5018,Op5018,Op5018,Op5018,Op5018,Op5018, // 5010
	Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028, // 5020
	Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5038,Op5039,Op503a,Op503b,Op____,Op____,Op____,Op____, // 5030
	Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008, // 5040
	Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058, // 5050
	Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068, // 5060
	Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5078,Op5079,Op507a,Op507b,Op____,Op____,Op____,Op____, // 5070
	Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008,Op5008, // 5080
	Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098, // 5090
	Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8, // 50a0
	Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b8,Op50b9,Op50ba,Op50bb,Op____,Op____,Op____,Op____, // 50b0
	Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 50c0
	Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50df, // 50d0
	Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e7,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8, // 50e0
	Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f8,Op50f9,Op50fa,Op50fb,Op____,Op____,Op____,Op____, // 50f0
	Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108, // 5100
	Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5118,Op5118,Op5118,Op5118,Op5118,Op5118,Op5118,Op5118, // 5110
	Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128, // 5120
	Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5138,Op5139,Op513a,Op513b,Op____,Op____,Op____,Op____, // 5130
	Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108, // 5140
	Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158, // 5150
	Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168, // 5160
	Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5178,Op5179,Op517a,Op517b,Op____,Op____,Op____,Op____, // 5170
	Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108,Op5108, // 5180
	Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198, // 5190
	Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8, // 51a0
	Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b8,Op51b9,Op51ba,Op51bb,Op____,Op____,Op____,Op____, // 51b0
	Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8, // 51c0
	Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51df, // 51d0
	Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e7,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8, // 51e0
	Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f8,Op51f9,Op51fa,Op51fb,Op____,Op____,Op____,Op____, // 51f0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5200
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5210
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5220
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5230
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5240
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5250
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5260
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5270
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5280
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5290
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 52a0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 52b0
	Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 52c0
	Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52df, // 52d0
	Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e7,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8, // 52e0
	Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f8,Op52f9,Op52fa,Op52fb,Op____,Op____,Op____,Op____, // 52f0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5300
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5310
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5320
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5330
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5340
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5350
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5360
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5370
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5380
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5390
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 53a0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 53b0
	Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 53c0
	Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53df, // 53d0
	Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e7,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8, // 53e0
	Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f8,Op53f9,Op53fa,Op53fb,Op____,Op____,Op____,Op____, // 53f0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5400
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5410
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5420
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5430
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5440
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5450
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5460
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5470
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5480
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5490
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 54a0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 54b0
	Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 54c0
	Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54df, // 54d0
	Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e7,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8, // 54e0
	Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f8,Op54f9,Op54fa,Op54fb,Op____,Op____,Op____,Op____, // 54f0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5500
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5510
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5520
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5530
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5540
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5550
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5560
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5570
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5580
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5590
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 55a0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 55b0
	Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 55c0
	Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55df, // 55d0
	Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e7,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8, // 55e0
	Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f8,Op55f9,Op55fa,Op55fb,Op____,Op____,Op____,Op____, // 55f0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5600
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5610
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5620
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5630
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5640
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5650
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5660
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5670
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5680
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5690
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 56a0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 56b0
	Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 56c0
	Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56df, // 56d0
	Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e7,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8, // 56e0
	Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f8,Op56f9,Op56fa,Op56fb,Op____,Op____,Op____,Op____, // 56f0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5700
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5710
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5720
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5730
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5740
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5750
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5760
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5770
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5780
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5790
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 57a0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 57b0
	Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 57c0
	Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57df, // 57d0
	Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e7,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8, // 57e0
	Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f8,Op57f9,Op57fa,Op57fb,Op____,Op____,Op____,Op____, // 57f0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5800
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5810
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5820
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5830
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5840
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5850
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5860
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5870
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5880
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5890
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 58a0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 58b0
	Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 58c0
	Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58df, // 58d0
	Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e7,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8, // 58e0
	Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f8,Op58f9,Op58fa,Op58fb,Op____,Op____,Op____,Op____, // 58f0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5900
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5910
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5920
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5930
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5940
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5950
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5960
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5970
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5980
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5990
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 59a0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 59b0
	Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 59c0
	Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59df, // 59d0
	Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e7,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8, // 59e0
	Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f8,Op59f9,Op59fa,Op59fb,Op____,Op____,Op____,Op____, // 59f0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5a00
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5a10
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5a20
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5a30
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5a40
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5a50
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5a60
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5a70
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5a80
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5a90
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 5aa0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 5ab0
	Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 5ac0
	Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5adf, // 5ad0
	Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae7,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8, // 5ae0
	Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af8,Op5af9,Op5afa,Op5afb,Op____,Op____,Op____,Op____, // 5af0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5b00
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5b10
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5b20
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5b30
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5b40
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5b50
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5b60
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5b70
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5b80
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5b90
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 5ba0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 5bb0
	Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 5bc0
	Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bdf, // 5bd0
	Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be7,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8, // 5be0
	Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf8,Op5bf9,Op5bfa,Op5bfb,Op____,Op____,Op____,Op____, // 5bf0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5c00
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5c10
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5c20
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5c30
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5c40
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5c50
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5c60
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5c70
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5c80
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5c90
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 5ca0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 5cb0
	Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 5cc0
	Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cdf, // 5cd0
	Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce7,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8, // 5ce0
	Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf8,Op5cf9,Op5cfa,Op5cfb,Op____,Op____,Op____,Op____, // 5cf0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5d00
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5d10
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5d20
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5d30
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5d40
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5d50
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5d60
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5d70
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5d80
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5d90
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 5da0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 5db0
	Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 5dc0
	Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5ddf, // 5dd0
	Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de7,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8, // 5de0
	Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df8,Op5df9,Op5dfa,Op5dfb,Op____,Op____,Op____,Op____, // 5df0
	Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5e00
	Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18, // 5e10
	Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28, // 5e20
	Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e38,Op5e39,Op5e3a,Op5e3b,Op____,Op____,Op____,Op____, // 5e30
	Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5e40
	Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58, // 5e50
	Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68, // 5e60
	Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e78,Op5e79,Op5e7a,Op5e7b,Op____,Op____,Op____,Op____, // 5e70
	Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08,Op5e08, // 5e80
	Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98, // 5e90
	Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8, // 5ea0
	Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb8,Op5eb9,Op5eba,Op5ebb,Op____,Op____,Op____,Op____, // 5eb0
	Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 5ec0
	Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5edf, // 5ed0
	Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee7,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8, // 5ee0
	Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef8,Op5ef9,Op5efa,Op5efb,Op____,Op____,Op____,Op____, // 5ef0
	Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5f00
	Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18, // 5f10
	Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28, // 5f20
	Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f38,Op5f39,Op5f3a,Op5f3b,Op____,Op____,Op____,Op____, // 5f30
	Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5f40
	Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58, // 5f50
	Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68, // 5f60
	Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f78,Op5f79,Op5f7a,Op5f7b,Op____,Op____,Op____,Op____, // 5f70
	Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08,Op5f08, // 5f80
	Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98, // 5f90
	Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8, // 5fa0
	Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb8,Op5fb9,Op5fba,Op5fbb,Op____,Op____,Op____,Op____, // 5fb0
	Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 5fc0
	Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fdf, // 5fd0
	Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe7,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8, // 5fe0
	Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff8,Op5ff9,Op5ffa,Op5ffb,Op____,Op____,Op____,Op____, // 5ff0
	Op6000,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6000
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6010
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6020
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6030
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6040
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6050
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6060
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6070
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6080
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 6090
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 60a0
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 60b0
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 60c0
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 60d0
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001, // 60e0
	Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op60ff, // 60f0
	Op6100,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6100
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6110
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6120
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6130
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6140
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6150
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6160
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6170
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6180
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 6190
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 61a0
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 61b0
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 61c0
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 61d0
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101, // 61e0
	Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op61ff, // 61f0
	Op6200,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6200
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6210
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6220
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6230
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6240
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6250
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6260
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6270
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6280
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 6290
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 62a0
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 62b0
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 62c0
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 62d0
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201, // 62e0
	Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op62ff, // 62f0
	Op6300,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6300
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6310
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6320
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6330
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6340
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6350
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6360
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6370
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6380
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 6390
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 63a0
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 63b0
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 63c0
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 63d0
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301, // 63e0
	Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op63ff, // 63f0
	Op6400,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6400
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6410
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6420
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6430
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6440
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6450
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6460
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6470
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6480
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 6490
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 64a0
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 64b0
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 64c0
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 64d0
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401, // 64e0
	Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op64ff, // 64f0
	Op6500,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6500
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6510
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6520
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6530
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6540
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6550
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6560
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6570
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6580
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 6590
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 65a0
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 65b0
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 65c0
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 65d0
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501, // 65e0
	Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op65ff, // 65f0
	Op6600,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6600
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6610
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6620
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6630
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6640
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6650
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6660
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6670
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6680
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 6690
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 66a0
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 66b0
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 66c0
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 66d0
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601, // 66e0
	Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op66ff, // 66f0
	Op6700,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6700
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6710
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6720
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6730
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6740
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6750
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6760
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6770
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6780
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 6790
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 67a0
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 67b0
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 67c0
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 67d0
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701, // 67e0
	Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op67ff, // 67f0
	Op6800,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6800
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6810
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6820
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6830
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6840
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6850
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6860
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6870
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6880
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 6890
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 68a0
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 68b0
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 68c0
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 68d0
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801, // 68e0
	Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op68ff, // 68f0
	Op6900,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6900
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6910
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6920
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6930
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6940
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6950
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6960
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6970
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6980
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 6990
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 69a0
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 69b0
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 69c0
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 69d0
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901, // 69e0
	Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op69ff, // 69f0
	Op6a00,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a00
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a10
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a20
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a30
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a40
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a50
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a60
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a70
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a80
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6a90
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6aa0
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6ab0
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6ac0
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6ad0
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01, // 6ae0
	Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6aff, // 6af0
	Op6b00,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b00
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b10
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b20
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b30
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b40
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b50
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b60
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b70
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b80
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6b90
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6ba0
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6bb0
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6bc0
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6bd0
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01, // 6be0
	Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6bff, // 6bf0
	Op6c00,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c00
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c10
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c20
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c30
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c40
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c50
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c60
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c70
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c80
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6c90
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6ca0
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6cb0
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6cc0
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6cd0
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01, // 6ce0
	Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6cff, // 6cf0
	Op6d00,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d00
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d10
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d20
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d30
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d40
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d50
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d60
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d70
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d80
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6d90
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6da0
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6db0
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6dc0
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6dd0
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01, // 6de0
	Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6dff, // 6df0
	Op6e00,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e00
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e10
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e20
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e30
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e40
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e50
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e60
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e70
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e80
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6e90
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6ea0
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6eb0
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6ec0
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6ed0
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01, // 6ee0
	Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6eff, // 6ef0
	Op6f00,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f00
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f10
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f20
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f30
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f40
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f50
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f60
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f70
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f80
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6f90
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6fa0
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6fb0
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6fc0
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6fd0
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01, // 6fe0
	Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6fff, // 6ff0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7000
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7010
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7020
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7030
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7040
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7050
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7060
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7070
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7080
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7090
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 70a0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 70b0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 70c0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 70d0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 70e0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 70f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7100
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7110
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7120
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7130
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7140
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7150
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7160
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7170
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7180
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7190
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 71a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 71b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 71c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 71d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 71e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 71f0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7200
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7210
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7220
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7230
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7240
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7250
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7260
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7270
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7280
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7290
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 72a0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 72b0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 72c0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 72d0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 72e0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 72f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7300
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7310
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7320
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7330
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7340
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7350
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7360
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7370
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7380
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7390
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 73a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 73b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 73c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 73d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 73e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 73f0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7400
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7410
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7420
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7430
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7440
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7450
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7460
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7470
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7480
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7490
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 74a0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 74b0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 74c0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 74d0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 74e0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 74f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7500
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7510
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7520
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7530
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7540
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7550
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7560
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7570
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7580
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7590
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 75a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 75b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 75c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 75d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 75e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 75f0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7600
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7610
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7620
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7630
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7640
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7650
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7660
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7670
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7680
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7690
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 76a0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 76b0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 76c0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 76d0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 76e0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 76f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7700
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7710
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7720
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7730
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7740
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7750
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7760
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7770
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7780
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7790
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 77a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 77b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 77c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 77d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 77e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 77f0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7800
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7810
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7820
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7830
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7840
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7850
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7860
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7870
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7880
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7890
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 78a0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 78b0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 78c0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 78d0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 78e0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 78f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7900
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7910
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7920
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7930
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7940
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7950
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7960
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7970
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7980
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7990
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 79a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 79b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 79c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 79d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 79e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 79f0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a00
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a10
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a20
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a30
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a40
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a50
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a60
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a70
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a80
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7a90
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7aa0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ab0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ac0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ad0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ae0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7af0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7b90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7ba0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7bb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7bc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7bd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7be0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7bf0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c00
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c10
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c20
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c30
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c40
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c50
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c60
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c70
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c80
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7c90
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ca0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7cb0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7cc0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7cd0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ce0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7cf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7d90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7da0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7db0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7dc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7dd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7de0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7df0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e00
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e10
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e20
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e30
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e40
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e50
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e60
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e70
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e80
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7e90
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ea0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7eb0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ec0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ed0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ee0
	Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000, // 7ef0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7f90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7fa0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7fb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7fc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7fd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7fe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 7ff0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8000
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8010
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8020
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8030
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8040
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8050
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8060
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8070
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8080
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8090
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 80a0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 80b0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 80c0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 80d0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 80e0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 80f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8100
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8110
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8120
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8130
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8140
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8150
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8160
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8170
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8180
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8190
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 81a0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 81b0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 81c0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 81d0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 81e0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 81f0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8200
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8210
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8220
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8230
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8240
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8250
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8260
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8270
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8280
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8290
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 82a0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 82b0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 82c0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 82d0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 82e0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 82f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8300
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8310
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8320
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8330
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8340
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8350
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8360
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8370
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8380
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8390
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 83a0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 83b0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 83c0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 83d0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 83e0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 83f0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8400
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8410
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8420
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8430
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8440
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8450
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8460
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8470
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8480
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8490
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 84a0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 84b0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 84c0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 84d0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 84e0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 84f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8500
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8510
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8520
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8530
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8540
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8550
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8560
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8570
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8580
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8590
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 85a0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 85b0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 85c0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 85d0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 85e0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 85f0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8600
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8610
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8620
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8630
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8640
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8650
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8660
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8670
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8680
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8690
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 86a0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 86b0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 86c0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 86d0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 86e0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 86f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8700
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8710
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8720
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8730
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8740
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8750
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8760
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8770
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8780
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8790
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 87a0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 87b0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 87c0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 87d0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 87e0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 87f0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8800
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8810
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8820
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8830
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8840
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8850
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8860
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8870
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8880
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8890
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 88a0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 88b0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 88c0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 88d0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 88e0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 88f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8900
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8910
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8920
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8930
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8940
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8950
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8960
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8970
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8980
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8990
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 89a0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 89b0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 89c0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 89d0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 89e0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 89f0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8a00
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8a10
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8a20
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8a30
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8a40
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8a50
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8a60
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8a70
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8a80
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8a90
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 8aa0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 8ab0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 8ac0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 8ad0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 8ae0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 8af0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8b00
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8b10
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8b20
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8b30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8b40
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8b50
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8b60
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8b70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8b80
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8b90
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 8ba0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 8bb0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 8bc0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 8bd0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 8be0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 8bf0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8c00
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8c10
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8c20
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8c30
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8c40
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8c50
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8c60
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8c70
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8c80
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8c90
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 8ca0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 8cb0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 8cc0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 8cd0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 8ce0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 8cf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8d00
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8d10
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8d20
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8d30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8d40
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8d50
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8d60
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8d70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8d80
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8d90
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 8da0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 8db0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 8dc0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 8dd0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 8de0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 8df0
	Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000, // 8e00
	Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f, // 8e10
	Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028, // 8e20
	Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____, // 8e30
	Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040, // 8e40
	Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op805f, // 8e50
	Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8067,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068, // 8e60
	Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____, // 8e70
	Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080, // 8e80
	Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op809f, // 8e90
	Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a7,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8, // 8ea0
	Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____, // 8eb0
	Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0, // 8ec0
	Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80df, // 8ed0
	Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e7,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8, // 8ee0
	Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____, // 8ef0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8f00
	Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f, // 8f10
	Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128, // 8f20
	Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8138,Op8139,Op813a,Op813b,Op____,Op____,Op____,Op____, // 8f30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8f40
	Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op815f, // 8f50
	Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8167,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168, // 8f60
	Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8178,Op8179,Op817a,Op817b,Op____,Op____,Op____,Op____, // 8f70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 8f80
	Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op819f, // 8f90
	Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a7,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8, // 8fa0
	Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b8,Op81b9,Op81ba,Op81bb,Op____,Op____,Op____,Op____, // 8fb0
	Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0, // 8fc0
	Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81df, // 8fd0
	Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e7,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8, // 8fe0
	Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____, // 8ff0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9000
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9010
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9020
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9030
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9040
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9050
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9060
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9070
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9080
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9090
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 90a0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 90b0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 90c0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 90d0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 90e0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 90f0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9100
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9110
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9120
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9130
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9140
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9150
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9160
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9170
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9180
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9190
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 91a0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 91b0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 91c0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 91d0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 91e0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 91f0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9200
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9210
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9220
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9230
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9240
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9250
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9260
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9270
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9280
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9290
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 92a0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 92b0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 92c0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 92d0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 92e0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 92f0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9300
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9310
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9320
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9330
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9340
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9350
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9360
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9370
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9380
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9390
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 93a0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 93b0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 93c0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 93d0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 93e0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 93f0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9400
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9410
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9420
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9430
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9440
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9450
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9460
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9470
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9480
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9490
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 94a0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 94b0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 94c0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 94d0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 94e0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 94f0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9500
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9510
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9520
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9530
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9540
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9550
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9560
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9570
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9580
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9590
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 95a0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 95b0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 95c0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 95d0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 95e0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 95f0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9600
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9610
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9620
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9630
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9640
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9650
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9660
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9670
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9680
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9690
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 96a0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 96b0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 96c0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 96d0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 96e0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 96f0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9700
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9710
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9720
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9730
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9740
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9750
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9760
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9770
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9780
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9790
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 97a0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 97b0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 97c0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 97d0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 97e0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 97f0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9800
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9810
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9820
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9830
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9840
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9850
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9860
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9870
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9880
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9890
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 98a0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 98b0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 98c0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 98d0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 98e0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 98f0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9900
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9910
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9920
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9930
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9940
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9950
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9960
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9970
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9980
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9990
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 99a0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 99b0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 99c0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 99d0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 99e0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 99f0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9a00
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9a10
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9a20
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9a30
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9a40
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9a50
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9a60
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9a70
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9a80
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9a90
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 9aa0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 9ab0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 9ac0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 9ad0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 9ae0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 9af0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9b00
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9b10
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9b20
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9b30
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9b40
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9b50
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9b60
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9b70
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9b80
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9b90
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 9ba0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 9bb0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 9bc0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 9bd0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 9be0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 9bf0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9c00
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9c10
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9c20
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9c30
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9c40
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9c50
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9c60
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9c70
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9c80
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9c90
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 9ca0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 9cb0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 9cc0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 9cd0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 9ce0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 9cf0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9d00
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9d10
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9d20
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9d30
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9d40
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9d50
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9d60
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9d70
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9d80
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9d90
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 9da0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 9db0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 9dc0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 9dd0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 9de0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 9df0
	Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000, // 9e00
	Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f, // 9e10
	Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028, // 9e20
	Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____, // 9e30
	Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040, // 9e40
	Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op905f, // 9e50
	Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9067,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068, // 9e60
	Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____, // 9e70
	Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080, // 9e80
	Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op909f, // 9e90
	Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a7,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8, // 9ea0
	Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____, // 9eb0
	Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0, // 9ec0
	Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90df, // 9ed0
	Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e7,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8, // 9ee0
	Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____, // 9ef0
	Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9f00
	Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f, // 9f10
	Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128, // 9f20
	Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9138,Op9139,Op913a,Op913b,Op____,Op____,Op____,Op____, // 9f30
	Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9f40
	Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op915f, // 9f50
	Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9167,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168, // 9f60
	Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9178,Op9179,Op917a,Op917b,Op____,Op____,Op____,Op____, // 9f70
	Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // 9f80
	Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op919f, // 9f90
	Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a7,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8, // 9fa0
	Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b8,Op91b9,Op91ba,Op91bb,Op____,Op____,Op____,Op____, // 9fb0
	Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0, // 9fc0
	Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91df, // 9fd0
	Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e7,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8, // 9fe0
	Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____, // 9ff0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a000
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a010
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a020
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a030
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a040
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a050
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a060
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a070
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a080
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a090
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a0a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a0b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a0c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a0d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a0e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a0f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a100
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a110
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a120
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a130
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a140
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a150
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a160
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a170
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a180
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a190
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a1a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a1b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a1c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a1d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a1e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a1f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a200
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a210
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a220
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a230
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a240
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a250
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a260
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a270
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a280
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a290
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a2a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a2b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a2c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a2d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a2e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a2f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a300
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a310
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a320
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a330
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a340
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a350
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a360
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a370
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a380
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a390
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a3a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a3b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a3c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a3d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a3e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a3f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a400
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a410
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a420
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a430
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a440
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a450
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a460
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a470
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a480
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a490
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a4a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a4b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a4c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a4d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a4e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a4f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a500
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a510
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a520
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a530
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a540
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a550
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a560
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a570
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a580
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a590
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a5a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a5b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a5c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a5d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a5e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a5f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a600
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a610
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a620
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a630
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a640
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a650
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a660
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a670
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a680
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a690
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a6a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a6b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a6c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a6d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a6e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a6f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a700
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a710
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a720
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a730
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a740
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a750
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a760
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a770
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a780
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a790
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a7a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a7b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a7c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a7d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a7e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a7f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a800
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a810
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a820
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a830
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a840
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a850
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a860
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a870
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a880
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a890
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a8a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a8b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a8c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a8d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a8e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a8f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a900
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a910
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a920
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a930
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a940
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a950
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a960
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a970
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a980
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a990
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a9a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a9b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a9c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a9d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a9e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // a9f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aa90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aaa0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aab0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aac0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aad0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aae0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aaf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ab90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aba0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // abb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // abc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // abd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // abe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // abf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ac90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aca0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // acb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // acc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // acd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ace0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // acf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ad90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ada0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // adb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // adc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // add0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ade0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // adf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ae90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aea0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aeb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aec0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aed0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aee0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aef0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // af90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // afa0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // afb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // afc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // afd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // afe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // aff0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // b000
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // b010
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // b020
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // b030
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // b040
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // b050
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // b060
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // b070
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // b080
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // b090
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // b0a0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // b0b0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // b0c0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // b0d0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // b0e0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // b0f0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b100
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // b110
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // b120
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // b130
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b140
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // b150
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // b160
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // b170
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b180
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // b190
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // b1a0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // b1b0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // b1c0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // b1d0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // b1e0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // b1f0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // b200
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // b210
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // b220
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // b230
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // b240
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // b250
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // b260
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // b270
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // b280
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // b290
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // b2a0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // b2b0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // b2c0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // b2d0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // b2e0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // b2f0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b300
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // b310
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // b320
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // b330
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b340
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // b350
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // b360
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // b370
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b380
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // b390
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // b3a0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // b3b0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // b3c0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // b3d0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // b3e0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // b3f0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // b400
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // b410
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // b420
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // b430
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // b440
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // b450
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // b460
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // b470
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // b480
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // b490
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // b4a0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // b4b0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // b4c0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // b4d0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // b4e0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // b4f0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b500
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // b510
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // b520
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // b530
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b540
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // b550
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // b560
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // b570
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b580
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // b590
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // b5a0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // b5b0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // b5c0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // b5d0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // b5e0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // b5f0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // b600
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // b610
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // b620
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // b630
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // b640
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // b650
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // b660
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // b670
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // b680
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // b690
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // b6a0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // b6b0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // b6c0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // b6d0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // b6e0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // b6f0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b700
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // b710
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // b720
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // b730
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b740
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // b750
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // b760
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // b770
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b780
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // b790
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // b7a0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // b7b0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // b7c0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // b7d0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // b7e0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // b7f0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // b800
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // b810
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // b820
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // b830
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // b840
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // b850
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // b860
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // b870
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // b880
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // b890
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // b8a0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // b8b0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // b8c0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // b8d0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // b8e0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // b8f0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b900
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // b910
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // b920
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // b930
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b940
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // b950
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // b960
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // b970
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // b980
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // b990
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // b9a0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // b9b0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // b9c0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // b9d0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // b9e0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // b9f0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // ba00
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // ba10
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // ba20
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // ba30
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // ba40
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // ba50
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // ba60
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // ba70
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // ba80
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // ba90
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // baa0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // bab0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // bac0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // bad0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // bae0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // baf0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bb00
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // bb10
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // bb20
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // bb30
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bb40
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // bb50
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // bb60
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // bb70
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bb80
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // bb90
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // bba0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // bbb0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // bbc0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // bbd0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // bbe0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // bbf0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // bc00
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // bc10
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // bc20
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // bc30
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // bc40
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // bc50
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // bc60
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // bc70
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // bc80
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // bc90
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // bca0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // bcb0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // bcc0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // bcd0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // bce0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // bcf0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bd00
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // bd10
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // bd20
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // bd30
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bd40
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // bd50
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // bd60
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // bd70
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bd80
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // bd90
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // bda0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // bdb0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // bdc0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // bdd0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // bde0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // bdf0
	Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000, // be00
	Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f, // be10
	Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028, // be20
	Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____, // be30
	Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040, // be40
	Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb05f, // be50
	Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb067,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068, // be60
	Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____, // be70
	Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080, // be80
	Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb09f, // be90
	Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a7,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8, // bea0
	Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____, // beb0
	Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0, // bec0
	Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0df, // bed0
	Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e7,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8, // bee0
	Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____, // bef0
	Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bf00
	Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f, // bf10
	Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128, // bf20
	Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb138,Opb139,Opb13a,Opb13b,Op____,Op____,Op____,Op____, // bf30
	Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bf40
	Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb15f, // bf50
	Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb167,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168, // bf60
	Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb178,Opb179,Opb17a,Opb17b,Op____,Op____,Op____,Op____, // bf70
	Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // bf80
	Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb19f, // bf90
	Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a7,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8, // bfa0
	Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b8,Opb1b9,Opb1ba,Opb1bb,Op____,Op____,Op____,Op____, // bfb0
	Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0, // bfc0
	Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1df, // bfd0
	Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e7,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8, // bfe0
	Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____, // bff0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // c000
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // c010
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // c020
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // c030
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // c040
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // c050
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // c060
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // c070
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // c080
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // c090
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // c0a0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // c0b0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // c0c0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // c0d0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // c0e0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // c0f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c100
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // c110
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // c120
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // c130
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c140
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // c150
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // c160
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // c170
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c180
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // c190
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // c1a0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // c1b0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // c1c0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // c1d0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // c1e0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // c1f0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // c200
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // c210
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // c220
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // c230
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // c240
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // c250
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // c260
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // c270
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // c280
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // c290
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // c2a0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // c2b0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // c2c0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // c2d0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // c2e0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // c2f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c300
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // c310
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // c320
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // c330
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c340
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // c350
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // c360
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // c370
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c380
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // c390
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // c3a0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // c3b0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // c3c0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // c3d0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // c3e0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // c3f0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // c400
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // c410
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // c420
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // c430
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // c440
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // c450
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // c460
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // c470
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // c480
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // c490
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // c4a0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // c4b0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // c4c0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // c4d0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // c4e0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // c4f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c500
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // c510
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // c520
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // c530
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c540
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // c550
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // c560
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // c570
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c580
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // c590
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // c5a0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // c5b0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // c5c0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // c5d0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // c5e0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // c5f0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // c600
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // c610
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // c620
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // c630
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // c640
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // c650
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // c660
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // c670
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // c680
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // c690
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // c6a0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // c6b0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // c6c0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // c6d0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // c6e0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // c6f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c700
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // c710
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // c720
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // c730
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c740
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // c750
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // c760
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // c770
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c780
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // c790
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // c7a0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // c7b0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // c7c0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // c7d0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // c7e0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // c7f0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // c800
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // c810
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // c820
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // c830
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // c840
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // c850
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // c860
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // c870
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // c880
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // c890
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // c8a0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // c8b0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // c8c0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // c8d0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // c8e0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // c8f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c900
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // c910
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // c920
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // c930
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c940
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // c950
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // c960
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // c970
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // c980
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // c990
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // c9a0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // c9b0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // c9c0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // c9d0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // c9e0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // c9f0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // ca00
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // ca10
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // ca20
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // ca30
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // ca40
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // ca50
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // ca60
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // ca70
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // ca80
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // ca90
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // caa0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // cab0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // cac0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // cad0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // cae0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // caf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cb00
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // cb10
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // cb20
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // cb30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cb40
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // cb50
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // cb60
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // cb70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cb80
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // cb90
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // cba0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // cbb0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // cbc0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // cbd0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // cbe0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // cbf0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // cc00
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // cc10
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // cc20
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // cc30
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // cc40
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // cc50
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // cc60
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // cc70
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // cc80
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // cc90
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // cca0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // ccb0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // ccc0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // ccd0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // cce0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // ccf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cd00
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // cd10
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // cd20
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // cd30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cd40
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // cd50
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // cd60
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // cd70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cd80
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // cd90
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // cda0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // cdb0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // cdc0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // cdd0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // cde0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // cdf0
	Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000, // ce00
	Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f, // ce10
	Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028, // ce20
	Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____, // ce30
	Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040, // ce40
	Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc05f, // ce50
	Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc067,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068, // ce60
	Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____, // ce70
	Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080, // ce80
	Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc09f, // ce90
	Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a7,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8, // cea0
	Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____, // ceb0
	Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0, // cec0
	Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0df, // ced0
	Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e7,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8, // cee0
	Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____, // cef0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cf00
	Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f, // cf10
	Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128, // cf20
	Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc138,Opc139,Opc13a,Opc13b,Op____,Op____,Op____,Op____, // cf30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cf40
	Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc15f, // cf50
	Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc167,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168, // cf60
	Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc178,Opc179,Opc17a,Opc17b,Op____,Op____,Op____,Op____, // cf70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // cf80
	Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc19f, // cf90
	Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a7,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8, // cfa0
	Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b8,Opc1b9,Opc1ba,Opc1bb,Op____,Op____,Op____,Op____, // cfb0
	Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0, // cfc0
	Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1df, // cfd0
	Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e7,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8, // cfe0
	Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____, // cff0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // d000
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // d010
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // d020
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // d030
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // d040
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // d050
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // d060
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // d070
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // d080
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // d090
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // d0a0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // d0b0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // d0c0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // d0d0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // d0e0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // d0f0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d100
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // d110
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // d120
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // d130
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d140
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // d150
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // d160
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // d170
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d180
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // d190
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // d1a0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // d1b0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // d1c0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // d1d0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // d1e0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // d1f0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // d200
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // d210
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // d220
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // d230
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // d240
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // d250
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // d260
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // d270
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // d280
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // d290
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // d2a0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // d2b0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // d2c0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // d2d0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // d2e0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // d2f0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d300
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // d310
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // d320
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // d330
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d340
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // d350
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // d360
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // d370
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d380
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // d390
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // d3a0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // d3b0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // d3c0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // d3d0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // d3e0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // d3f0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // d400
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // d410
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // d420
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // d430
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // d440
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // d450
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // d460
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // d470
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // d480
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // d490
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // d4a0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // d4b0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // d4c0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // d4d0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // d4e0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // d4f0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d500
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // d510
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // d520
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // d530
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d540
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // d550
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // d560
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // d570
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d580
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // d590
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // d5a0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // d5b0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // d5c0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // d5d0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // d5e0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // d5f0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // d600
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // d610
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // d620
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // d630
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // d640
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // d650
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // d660
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // d670
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // d680
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // d690
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // d6a0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // d6b0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // d6c0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // d6d0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // d6e0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // d6f0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d700
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // d710
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // d720
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // d730
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d740
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // d750
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // d760
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // d770
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d780
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // d790
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // d7a0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // d7b0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // d7c0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // d7d0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // d7e0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // d7f0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // d800
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // d810
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // d820
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // d830
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // d840
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // d850
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // d860
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // d870
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // d880
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // d890
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // d8a0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // d8b0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // d8c0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // d8d0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // d8e0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // d8f0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d900
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // d910
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // d920
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // d930
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d940
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // d950
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // d960
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // d970
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // d980
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // d990
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // d9a0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // d9b0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // d9c0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // d9d0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // d9e0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // d9f0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // da00
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // da10
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // da20
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // da30
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // da40
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // da50
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // da60
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // da70
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // da80
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // da90
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // daa0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // dab0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // dac0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // dad0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // dae0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // daf0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // db00
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // db10
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // db20
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // db30
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // db40
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // db50
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // db60
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // db70
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // db80
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // db90
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // dba0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // dbb0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // dbc0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // dbd0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // dbe0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // dbf0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // dc00
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // dc10
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // dc20
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // dc30
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // dc40
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // dc50
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // dc60
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // dc70
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // dc80
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // dc90
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // dca0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // dcb0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // dcc0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // dcd0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // dce0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // dcf0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // dd00
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // dd10
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // dd20
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // dd30
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // dd40
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // dd50
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // dd60
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // dd70
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // dd80
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // dd90
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // dda0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // ddb0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // ddc0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // ddd0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // dde0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // ddf0
	Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000, // de00
	Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f, // de10
	Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028, // de20
	Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____, // de30
	Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040, // de40
	Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd05f, // de50
	Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd067,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068, // de60
	Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____, // de70
	Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080, // de80
	Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd09f, // de90
	Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a7,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8, // dea0
	Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____, // deb0
	Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0, // dec0
	Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0df, // ded0
	Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e7,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8, // dee0
	Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____, // def0
	Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // df00
	Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f, // df10
	Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128, // df20
	Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd138,Opd139,Opd13a,Opd13b,Op____,Op____,Op____,Op____, // df30
	Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // df40
	Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd15f, // df50
	Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd167,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168, // df60
	Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd178,Opd179,Opd17a,Opd17b,Op____,Op____,Op____,Op____, // df70
	Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // df80
	Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd19f, // df90
	Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a7,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8, // dfa0
	Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b8,Opd1b9,Opd1ba,Opd1bb,Op____,Op____,Op____,Op____, // dfb0
	Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0, // dfc0
	Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1df, // dfd0
	Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e7,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8, // dfe0
	Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____, // dff0
	Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008, // e000
	Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018, // e010
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // e020
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // e030
	Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048, // e040
	Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058, // e050
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // e060
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // e070
	Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088, // e080
	Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098, // e090
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // e0a0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // e0b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e0c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e0d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e0e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e0f0
	Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108, // e100
	Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118, // e110
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // e120
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // e130
	Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148, // e140
	Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158, // e150
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // e160
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // e170
	Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188, // e180
	Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198, // e190
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // e1a0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // e1b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e1c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e1d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e1e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e1f0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // e200
	Ope210,Ope210,Ope210,Ope210,Ope210,Ope210,Ope210,Ope210,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // e210
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // e220
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // e230
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // e240
	Ope250,Ope250,Ope250,Ope250,Ope250,Ope250,Ope250,Ope250,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // e250
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // e260
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // e270
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // e280
	Ope290,Ope290,Ope290,Ope290,Ope290,Ope290,Ope290,Ope290,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // e290
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // e2a0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // e2b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e2c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e2d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e2e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e2f0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // e300
	Ope310,Ope310,Ope310,Ope310,Ope310,Ope310,Ope310,Ope310,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // e310
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // e320
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // e330
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // e340
	Ope350,Ope350,Ope350,Ope350,Ope350,Ope350,Ope350,Ope350,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // e350
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // e360
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // e370
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // e380
	Ope390,Ope390,Ope390,Ope390,Ope390,Ope390,Ope390,Ope390,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // e390
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // e3a0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // e3b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e3c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e3d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e3e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e3f0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // e400
	Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // e410
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // e420
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // e430
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // e440
	Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // e450
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // e460
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // e470
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // e480
	Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // e490
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // e4a0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // e4b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e4c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e4d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e4e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e4f0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // e500
	Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // e510
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // e520
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // e530
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // e540
	Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // e550
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // e560
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // e570
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // e580
	Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // e590
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // e5a0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // e5b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e5c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e5d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e5e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e5f0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // e600
	Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // e610
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // e620
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // e630
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // e640
	Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // e650
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // e660
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // e670
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // e680
	Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // e690
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // e6a0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // e6b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e6c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e6d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e6e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e6f0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // e700
	Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // e710
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // e720
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // e730
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // e740
	Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // e750
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // e760
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // e770
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // e780
	Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // e790
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // e7a0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // e7b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e7c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e7d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e7e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e7f0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // e800
	Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // e810
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // e820
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // e830
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // e840
	Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // e850
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // e860
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // e870
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // e880
	Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // e890
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // e8a0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // e8b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e8c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e8d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e8e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e8f0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // e900
	Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // e910
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // e920
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // e930
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // e940
	Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // e950
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // e960
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // e970
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // e980
	Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // e990
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // e9a0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // e9b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e9c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e9d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e9e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // e9f0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // ea00
	Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // ea10
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // ea20
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // ea30
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // ea40
	Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // ea50
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // ea60
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // ea70
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // ea80
	Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // ea90
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // eaa0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // eab0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eac0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ead0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eae0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eaf0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // eb00
	Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // eb10
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // eb20
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // eb30
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // eb40
	Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // eb50
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // eb60
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // eb70
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // eb80
	Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // eb90
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // eba0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // ebb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ebc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ebd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ebe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ebf0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // ec00
	Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // ec10
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // ec20
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // ec30
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // ec40
	Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // ec50
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // ec60
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // ec70
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // ec80
	Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // ec90
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // eca0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // ecb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ecc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ecd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ece0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ecf0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // ed00
	Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // ed10
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // ed20
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // ed30
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // ed40
	Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // ed50
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // ed60
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // ed70
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // ed80
	Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // ed90
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // eda0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // edb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // edc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // edd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ede0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // edf0
	Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08, // ee00
	Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18, // ee10
	Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028, // ee20
	Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038, // ee30
	Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48, // ee40
	Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58, // ee50
	Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068, // ee60
	Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078, // ee70
	Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88, // ee80
	Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98, // ee90
	Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8, // eea0
	Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8, // eeb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eec0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eed0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eee0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eef0
	Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08, // ef00
	Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18, // ef10
	Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128, // ef20
	Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138, // ef30
	Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48, // ef40
	Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58, // ef50
	Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168, // ef60
	Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178, // ef70
	Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88, // ef80
	Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98, // ef90
	Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8, // efa0
	Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8, // efb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // efc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // efd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // efe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // eff0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f000
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f010
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f020
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f030
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f040
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f050
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f060
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f070
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f080
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f090
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f0a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f0b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f0c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f0d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f0e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f0f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f100
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f110
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f120
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f130
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f140
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f150
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f160
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f170
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f180
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f190
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f1a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f1b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f1c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f1d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f1e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f1f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f200
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f210
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f220
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f230
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f240
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f250
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f260
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f270
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f280
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f290
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f2a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f2b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f2c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f2d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f2e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f2f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f300
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f310
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f320
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f330
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f340
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f350
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f360
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f370
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f380
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f390
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f3a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f3b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f3c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f3d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f3e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f3f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f400
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f410
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f420
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f430
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f440
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f450
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f460
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f470
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f480
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f490
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f4a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f4b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f4c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f4d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f4e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f4f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f500
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f510
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f520
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f530
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f540
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f550
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f560
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f570
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f580
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f590
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f5a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f5b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f5c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f5d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f5e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f5f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f600
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f610
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f620
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f630
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f640
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f650
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f660
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f670
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f680
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f690
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f6a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f6b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f6c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f6d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f6e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f6f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f700
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f710
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f720
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f730
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f740
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f750
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f760
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f770
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f780
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f790
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f7a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f7b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f7c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f7d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f7e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f7f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f800
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f810
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f820
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f830
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f840
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f850
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f860
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f870
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f880
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f890
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f8a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f8b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f8c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f8d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f8e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f8f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f900
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f910
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f920
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f930
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f940
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f950
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f960
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f970
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f980
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f990
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f9a0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f9b0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f9c0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f9d0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f9e0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // f9f0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fa90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // faa0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fab0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fac0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fad0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fae0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // faf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fb90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fba0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fbb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fbc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fbd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fbe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fbf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fc90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fca0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fcb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fcc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fcd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fce0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fcf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fd90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fda0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fdb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fdc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fdd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fde0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fdf0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fe90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fea0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // feb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fec0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fed0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fee0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // fef0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff00
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff10
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff20
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff30
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff40
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff50
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff60
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff70
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff80
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ff90
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ffa0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ffb0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ffc0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ffd0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____, // ffe0
	Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____  // fff0
};
// --------------------------- Footer --------------------------

